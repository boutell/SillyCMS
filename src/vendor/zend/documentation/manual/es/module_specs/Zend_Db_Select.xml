<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 20115 -->
    <!-- Reviewed: no -->
<sect1 id="zend.db.select">

    <title>Zend_Db_Select</title>

    <sect2 id="zend.db.select.introduction">

        <title>Descripción del Objeto Select</title>

        <para> El objeto <classname>Zend_Db_Select</classname> object representa
            una declaración de consulta <acronym>SELECT</acronym> de
                <acronym>SQL</acronym> . La clase tiene métodos para agregar
            partes individuales a la consulta. Se pueden especificar algunas
            partes de la consulta usando los métodos en <acronym>PHP</acronym> y
            sus estructuras de datos, y la clase forma la sintaxis
                <acronym>SLQ</acronym> correcta. Después de construir la
            consulta, puede ejecutarla como si se hubiera escrito como un
            string. </para>

        <para> Las posibilidades de <classname>Zend_Db_Select</classname>
            incluyen: </para>

        <itemizedlist>
            <listitem>
                <para> Métodos Orientados a objetos para especificar consultas
                        <acronym>SQL</acronym> pieza-a-pieza; </para>
            </listitem>

            <listitem>
                <para> Abstracción de partes de las consultas
                        <acronym>SQL</acronym> , independiente de la Base de
                    datos; </para>
            </listitem>

            <listitem>
                <para> Entrecomillado automático de identificadores de metadatos
                    en la mayoría de los casos, soportanto identificadores que
                    contienen palabras reservadas de <acronym>SQL</acronym> y
                    caracteres especiales; </para>
            </listitem>

            <listitem>
                <para> Entrecomillado de identificadores y valores, para ayudar
                    a reducir el riesgo de ataque por inyección
                        <acronym>SQL</acronym> . </para>
            </listitem>
        </itemizedlist>

        <para> El uso de <classname>Zend_Db_Select</classname> no es
            obligatorio. Para consultas <acronym>SELECT</acronym> muy simples,
            es usualmente más simple especificar la consulta completa como un
            string y ejecutarla usando un método del Adapter como
                <methodname>query()</methodname> o
                <methodname>fetchAll()</methodname> . Usar
                <classname>Zend_Db_Select</classname> es útil si se necesita
            ensamblar una consulta <acronym>SELECT</acronym> proceduralmente, o
            basada en condiciones lógicas en la aplicación. </para>

    </sect2>

    <sect2 id="zend.db.select.creating">

        <title>Creando un Objeto Select</title>

        <para> Se puede crear una instancia del objeto
                <classname>Zend_Db_Select</classname> usando el método
                <methodname>select()</methodname> de un objeto
                <classname>Zend_Db_Adapter_Abstract</classname> . </para>

        <example id="zend.db.select.creating.example-db">

            <title>Ejemplo del método select() del adaptador</title>

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...options... );
$select = $db->select();
]]></programlisting>

        </example>

        <para> Otra manera de crear el objeto
                <classname>Zend_Db_Select</classname> es con su constructor,
            especificando el adaptador de base de datos como un argumento. </para>

        <example id="zend.db.select.creating.example-new">

            <title>Ejemplo de creación de un nuevo objeto Select</title>

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...options... );
$select = new Zend_Db_Select($db);
]]></programlisting>

        </example>

    </sect2>

    <sect2 id="zend.db.select.building">

        <title>Construyendo consultas Select</title>

        <para> Cuando se construye una consulta, puede agregar cláusulas a ésta,
            una por una. Hay un método separado para agregar cada una al objeto
                <classname>Zend_Db_Select</classname> . </para>

        <example id="zend.db.select.building.example">

            <title>Ejemplo de uso de métodos que agregan cláusulas</title>

            <programlisting language="php"><![CDATA[
// Crear el objeto Zend_Db_Select
$select = $db->select();

// Agregar una cláusula FROM
$select->from( ...specify table and columns... )

// Agregar una cláusula WHERE
$select->where( ...specify search criteria... )

// Agregar una cláusula ORDER BY
$select->order( ...specify sorting criteria... );
]]></programlisting>

        </example>

        <para> También puede utilizar la mayoría de los métodos del objeto
                <classname>Zend_Db_Select</classname> con una interfaz fluida.
            Una interfaz fluida significa que cada método devuelve una
            referencia al objeto que se ha llamado, así se puede llamar
            inmediatamente a otro método. </para>

        <example id="zend.db.select.building.example-fluent">

            <title>Ejemplo de uso de la interfaz fluida</title>

            <programlisting language="php"><![CDATA[
$select = $db->select()
    ->from( ...specify table and columns... )
    ->where( ...specify search criteria... )
    ->order( ...specify sorting criteria... );
]]></programlisting>

        </example>

        <para>Los ejemplos en esta sección muestran el uso de la interfaz
            fluída, pero también se puede usar la interfaz no-fluída en todos
            los casos. A menudo es necesario utilizar la interfaz no-fluída, por
            ejemplo, si su aplicación necesita realizar cierta lógica antes de
            añadir una cláusula a la consulta.</para>

        <sect3 id="zend.db.select.building.from">

            <title>Agregando una cláusula FROM</title>

            <para> Especifique la tabla para esta consulta usando el método
                    <methodname>from()</methodname> . Se puede especificar el
                nombre de la tabla como un string.
                    <classname>Zend_Db_Select</classname> aplica el
                identificador entrecomillando el nombre de la tabla, así puede
                utilizar caracteres especiales. </para>

            <example id="zend.db.select.building.from.example">

                <title>Ejemplo del método from()</title>

                <programlisting language="php"><![CDATA[
// Construye la consulta:
//   SELECT *
//   FROM "products"

$select = $db->select()
             ->from( 'products' );
]]></programlisting>

            </example>

            <para> Puede especificar un nombre de correlación (también llamado a
                veces "alias de tabla") para una tabla. En lugar de un string,
                se usa un array asociativo que mapee el nombre de correlación
                con el nombre de la tabla. En otras cláusulas de consulta
                    <acronym>SQL</acronym> , utilice nombre de correlación. Si
                su consulta se une con más de una tabla,
                    <classname>Zend_Db_Select</classname> genera una correlación
                unica de nombres basados en el nombre de la tabla, para una
                tabla a la cual no se le espicifique un nombre de correlación. </para>

            <example id="zend.db.select.building.from.example-cname">

                <title>Ejemplo especificando una tabla con nombre de
                    correlación</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p.*
//   FROM "products" AS p

$select = $db->select()
             ->from( array('p' => 'products') );
]]></programlisting>

            </example>

            <para> Algunos <acronym>RDBMS</acronym> apoyan el uso de un
                especificador de esquema para una tabla. Puede especificar el
                nombre de la tabla como " "<code>schemaName.tableName</code>" ",
                donde <classname>Zend_Db_Select</classname> entrecomillará cada
                parte individualmente, o tambien puedes especificar el nombre de
                esquema por separado. Un nombre de esquema especificado en el
                nombre de la tabla toma precedencia en sobre un esquema dado por
                separado en el caso de que ambos sean dados. </para>

            <example id="zend.db.select.building.from.example-schema">

                <title>Ejemplo especificando un nombre de esquema</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT *
//   FROM "myschema"."products"

$select = $db->select()
             ->from( 'myschema.products' );

// o

$select = $db->select()
             ->from('products', '*', 'myschema');
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.columns">

            <title>Agregando Columnas</title>

            <para> En el segundo argumento del método
                    <methodname>from()</methodname> , puede especificar las
                columnas que seleccionar desde la tabla respectiva. Si no
                especifica columnas, por defecto será "
                    <methodname>*</methodname> ", el comodín
                    <acronym>SQL</acronym> para "todas las columnas". </para>

            <para>Puede listar las columnas en un simple array de strings, o en
                un array asociativo mapeando los alias de columnas a su nombre
                de tabla. Si solo se especifica una columna en la consulta y no
                necesita especificar un alias de columna, puede listarla solo
                con un string en lugar de un array.</para>

            <para> Si se entrega un array vacío como el argumento de las tablas,
                no se incluirán columnas en el resultado. Vea un <link
                    linkend="zend.db.select.building.join.example-no-columns"
                    >código de ejemplo</link> en la sección del método
                    <methodname>join()</methodname> . </para>

            <para> Puedes especificar el nombre de columna como "
                    <code>nombreCorrelacionado.nombreDeColumna</code> ".
                    <classname>Zend_Db_Select</classname> entrecomillará cada
                parte individualmente. Si no especifica un nombre de correlación
                para una columna, se usará el nombre de correlación para la
                tabla nombrada en el método actual
                    <methodname>from()</methodname> . </para>

            <example id="zend.db.select.building.columns.example">

                <title>Ejemplos especificando columnas</title>

                <programlisting language="php"><![CDATA[
// Construir esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'));

// Construir la misma consulta, especificando nombres de correlación
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('p.product_id', 'p.product_name'));

// Construir esta consulta con una alias para una columna:
//   SELECT p."product_id" AS prodno, p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('prodno' => 'product_id', 'product_name'));
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.columns-expr">

            <title>Agregando una Expresión en las Columns</title>

            <para> Las columnas en consultas <acronym>SQL</acronym> a veces son
                expresiones, no simples columnas de una tabla. Las expresiones
                no deberían tener nombres de correlación o entrecomillado
                aplicado. Si sus columnas contienen paréntesis,
                    <classname>Zend_Db_Select</classname> las reconoce como una
                expresión. </para>

            <para> Tambien puede crear un objeto de tipo
                    <classname>Zend_Db_Expr</classname> explícitamente, para
                prevenir que el string sea tratado como columna.
                    <classname>Zend_Db_Expr</classname> es una clase mínima, que
                contiene un simple string. <classname>Zend_Db_Select</classname>
                reconoce el objeto de tipo <classname>Zend_Db_Expr</classname> y
                lo convierte de vuelta en el string, pero no le aplica ninguna
                alteración, tal como el entrecomillado o la correlación de
                nombres. </para>

            <note>

                <para> El Uso de <classname>Zend_Db_Expr</classname> para
                    nombres de columnas no es necesario si la expresión de la
                    columna contiene paréntesis;
                        <classname>Zend_Db_Select</classname> reconoce y trata
                    el string como expresión, saltándose el entrecomillado y la
                    correlación de nombres. </para>

            </note>

            <example id="zend.db.select.building.columns-expr.example">

                <title>Ejemplos especificando columnas que contienen
                    expresiones</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", LOWER(product_name)
//   FROM "products" AS p
// Una expresion con parentesis implicitamente se transforma en
// un Zend_Db_Expr.

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'LOWER(product_name)'));

// Construya esta consulta:
//   SELECT p."product_id", (p.cost * 1.08) AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' => '(p.cost * 1.08)')
                   );

// Construya esta consulta usando Zend_Db_Expr explícitamente:
//   SELECT p."product_id", p.cost * 1.08 AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' =>
                              new Zend_Db_Expr('p.cost * 1.08'))
                    );
]]></programlisting>

            </example>

            <para> En los casos anteriores,
                    <classname>Zend_Db_Select</classname> no altera el string
                para aplicar correlación de nombres o entrecomillado de
                identificadores. Si estos cambios son necesarios para resolver
                ambigüedades, deberías realizar cambios manualmente en el
                string. </para>

            <para> Si el nombre de su columna es alguna palabra reservada de
                    <acronym>SQL</acronym> o contiene caracteres especiales,
                debería usar el método
                    <methodname>quoteIdentifier()</methodname> del Adapdator e
                interpolar el resultado en un string. El método
                    <methodname>quoteIdentifier()</methodname> usa
                entrecomillado <acronym>SQL</acronym> para delimitar el
                identificador, the identifier, dejando en claro que es un
                identificador de tabla o columna y no otra parte de la sintaxis
                    <acronym>SQL</acronym> . </para>

            <para> Su código es más independiente de la base de datos si se usa
                el método <methodname>quoteIdentifier()</methodname> en vez de
                las excribir literalmente las comillas en la cadena, debido a
                que algunos <acronym>RDBMS</acronym> no usan simbolos estándar
                para entrecomillar identificadores. El método
                    <methodname>quoteIdentifier()</methodname> está diseñado
                para usar los símbolos apropiados para entrecomillar basado en
                el tipo del adaptador. El método
                    <methodname>quoteIdentifier()</methodname> también escapa
                cual caracter de comilla que aparezca en el nombre del
                identificador mismo. </para>

            <example id="zend.db.select.building.columns-quoteid.example">

                <title>Ejemplo de entrecomillado de columnas en una
                    expresión</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta, entrecomillando el nombre
// especial de la columna llamada "from" en la expresión:
//   SELECT p."from" + 10 AS origin
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('origin' =>
                              '(p.' . $db->quoteIdentifier('from') . ' + 10)')
                   );
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.columns-atomic">

            <title>Agregar columnas a una tabla FROM o JOIN existente</title>

            <para> Puede haber casos en los que desea agregar columnas a una
                tabla FROM o JOIN después de que estos métodos han sido
                llamados. El método <methodname>columns()</methodname> permite
                agregar columnas en cualquier punto antes de ejecutar la
                consulta. Puedes pasar las columnas bien como un string, un
                    <classname>Zend_Db_Expr</classname> o un array de estos
                elementos. El segundo argumento para este método puede ser
                omitido, implicando que las columnas serán agregadas a una tabla
                FROM, en otro caso debería usarse un nombre de correlación
                existente. </para>

            <example id="zend.db.select.building.columns-atomic.example">

                <title> Ejemplos agregando columnas con el método
                    columns()</title>

                <programlisting language="php"><![CDATA[
// Construir la consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'product_id')
             ->columns('product_name');

// Construir la misma consulta, especificando correlación de nombres:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'p.product_id')
             ->columns('product_name', 'p');
             // Alternativamente puede usar columns('p.product_name')
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.join">

            <title>Agregar Otra Tabla a la Consulta Query con JOIN</title>

            <para> Muchas consultas útiles involucran el uso de un
                    <acronym>JOIN</acronym> para combinar filas de multiples
                tablas. Puedes agregar tablas a una consulta
                    <classname>Zend_Db_Select</classname> usando el método
                    <methodname>join()</methodname> . Usar este método, es
                similar al método <methodname>from()</methodname> , excepto que
                puedes especificar una condición de unión en la mayoría de los
                casos. </para>

            <example id="zend.db.select.building.join.example">

                <title>Ejemplo del método join()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name", l.*
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id');
]]></programlisting>

            </example>

            <para> El segundo argumento <methodname>join()</methodname> es un
                string que es usado como condición de unión. Esta es una
                expresión que declara un criterio por el cual las filas en una
                tabla concuerdan con las filas de la otra tabla. Puedes
                especificar correlación de nombres en esta expresión. </para>

            <note>

                <para> No se aplica entrecomillado en la expresión especificada
                    para la condición de unión; si tienes problemas con nombres
                    que necesitan ser entrecomillados, deberás usar
                        <methodname>quoteIdentifier()</methodname> para formar
                    el string de condición de unión. </para>

            </note>

            <para> El tercer argumento <methodname>join()</methodname> es un
                array de nombres de columnas, como al usar el método
                    <methodname>from()</methodname> . Este es por defecto "
                    <code>*</code> ", soporta correlación de nombres,
                expresiones, y <classname>Zend_Db_Expr</classname> de la misma
                manera que el array de nombres de columnas en el método
                    <methodname>from()</methodname> . </para>

            <para> Para no seleccionar columnas de una tabla, use un array vacío
                para la lista de columnas. El uso de esto trabaja con el método
                    <methodname>from()</methodname> también, pero en general
                deseará algunas columnas de la tabla primaria en sus consultas,
                a la vez que no se desean columnas de la tabla unida. </para>

            <example id="zend.db.select.building.join.example-no-columns">

                <title>Ejemplo especificando ninguna columna</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array() ); // empty list of columns
]]></programlisting>

                <para> Note el array vacío <methodname>array()</methodname> en
                    el ejemplo anterior en lugar de una lista de columnas de la
                    tabla unida. </para>

            </example>

            <para> SQL tiene muchos tipos de uniones. Vea una lista a
                continuación para los métodos que soporta cada tipo de unión en
                    <classname>Zend_Db_Select</classname> . </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <command>INNER JOIN</command> con los métodos
                            <methodname>join(table, join,
                            [columns])</methodname> o
                            <methodname>joinInner(table, join,
                            [columns])</methodname> . </para>

                    <para>Éste es el tipo de unión más comun. Las filas de cada
                        tabla son comparadas usando la condición de unión
                        especificada. El resultado incluye solo las filas que
                        satisfacen la condición. El resultado puede ser vacío si
                        no hay filas que satisfagan la condición.</para>

                    <para> Todos los <acronym>RDBMS</acronym> soportan este tipo
                        de unión. </para>
                </listitem>

                <listitem>
                    <para>
                        <command>LEFT JOIN</command> con el método
                            <methodname>joinLeft(table, condition,
                            [columns])</methodname> . </para>

                    <para>Todas las filas de tabla a la izquierda del operando
                        son incluidas, pareando las filas de la tabla a la
                        derecha del operando, y las columnas de la tabla a la
                        derecha del operando son rellenadas con <constant>NULL</constant>s si no
                        existen filas que coincidan con la tabla a la
                        izquierda.</para>

                    <para> Todos los <acronym>RDBMS</acronym> soportan este tipo
                        de unión. </para>
                </listitem>

                <listitem>
                    <para>
                        <command>RIGHT JOIN</command> con el método
                            <methodname>joinRight(table, condition,
                            [columns])</methodname> . </para>

                    <para>Unión exterior por la derecha es el complementario de
                        la unión exterior por la izquierda. Todas las filas de
                        la tabla a la derecha del operando son incluidas,
                        pareando las filas de la tabla a la izquierda del
                        operando incluidas, y las columnas de la tabla a la
                        izquierda del operando son rellenadas con <constant>NULL</constant>s si no
                        existen filas que coincidan con la tabla de la
                        derecha.</para>

                    <para> Algunos <acronym>RDBMS</acronym> no soportan este
                        tipo de join, pero en general, cualquier unión por la
                        derecha puede representarse por una unión por la
                        izquierda invirtiendo el orden de las tablas. </para>
                </listitem>

                <listitem>
                    <para>
                        <command>FULL JOIN</command> con el método
                            <methodname>joinFull(table, condition,
                            [columns])</methodname> . </para>

                    <para>Una unión externa total es como una combinación de una
                        unión exterior por la izquierda y una unión exterior por
                        la derecha. Todas las filas de ambas tablas son
                        incluidas, vinculadas entre sí en la misma fila si
                        satisfacen la condición de unión, y en otro caso, se
                        vinculan con valores <constant>NULL</constant>'s en lugar de columnas de la
                        otra tabla.</para>

                    <para> Algunos <acronym>RDBMS</acronym> no soportan este
                        tipo de unión. </para>
                </listitem>

                <listitem>
                    <para>
                        <command>CROSS JOIN</command> con el método
                            <methodname>joinCross(table, [columns])</methodname>
                        . </para>

                    <para> Una unión cruzada es un Producto Cartesiano. Cada
                        fila en la primera tabla es pareada con cada una en la
                        segunda tabla. Por lo tanto, el número de filas en el
                        resultado es igual al producto del número de filas en
                        cada tabla. Puede filtrar el conjunto de resultados con
                        el uso de condiciones en un cláusula
                            <constant>WHERE</constant> ; de esta forma una unión
                        cruzada es similar a la antigua sintaxis de unión en
                            <acronym>SQL</acronym> -89. </para>

                    <para> El método <methodname>joinCross()</methodname> no
                        tiene parámetros para especificar una condición de
                        unión. Algunos <acronym>RDBMS</acronym> S no soportan
                        este tipo de unión. </para>
                </listitem>

                <listitem>
                    <para>
                        <command>NATURAL JOIN</command> con el método
                            <methodname>joinNatural(table,
                            [columns])</methodname> . </para>

                    <para> Una unión natural compara cualquier columa(s) que
                        aparezca con el nombre en ambas tablas. La comparación
                        es el equivalente de todas las columna(s); comparando
                        las columnas usando desigualdad no es una unión natural.
                        Solo la unión interna natural es soportada por este API,
                        aun cuando <acronym>SQL</acronym> permita una unión
                        externa natural. </para>

                    <para> El método <methodname>joinNatural()</methodname> no
                        tiene parámetros para especificar una condición. </para>
                </listitem>
            </itemizedlist>

            <para> Además de los métodos de unión, puede simplificar las
                consultas usando métodos JoinUsing. En vez de proveer una
                condición completa a la unión, simplemente pase el nombre de
                columna en la que se hará la unión y el objeto
                    <classname>Zend_Db_Select</classname> completa la condición. </para>

            <example id="zend.db.select.building.joinusing.example">

                <title>Ejemplo de método joinUsing()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT *
//   FROM "table1"
//   JOIN "table2"
//   ON "table1".column1 = "table2".column1
//   WHERE column2 = 'foo'

$select = $db->select()
             ->from('table1')
             ->joinUsing('table2', 'column1')
             ->where('column2 = ?', 'foo');
]]></programlisting>

            </example>

            <para> Cada uno de los métodos aplicables para uniones en el
                componente <classname>Zend_Db_Select</classname> tiene su
                correspondiente método 'using' (usando) </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <methodname>joinUsing(table, join,
                            [columns])</methodname> y
                            <methodname>joinInnerUsing(table, join,
                            [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinLeftUsing(table, join,
                            [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinRightUsing(table, join,
                            [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinFullUsing(table, join,
                            [columns])</methodname>
                    </para>
                </listitem>
            </itemizedlist>

        </sect3>

        <sect3 id="zend.db.select.building.where">

            <title>Agregar una cláusula WHERE</title>

            <para> Puede especificar un criterio para restringir las filas de
                resultado usando el método <methodname>where()</methodname> . El
                primer argumento de este método es una expresión
                    <acronym>SQL</acronym> , y esta expresión es usada como una
                expresión <acronym>SQL</acronym>
                <constant>WHERE</constant> en la consulta. </para>

            <example id="zend.db.select.building.where.example">

                <title>Ejemplo del método where()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE price > 100.00

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > 100.00');
]]></programlisting>

            </example>

            <note>

                <para> No se aplica entrecomillado en una expresión dada en el
                    método <methodname>where()</methodname> u
                        <methodname>orWhere()</methodname> . Si tiene nombres de
                    columnas que necesitan ser entrecomillados, debe usar el
                    método <methodname>quoteIdentifier()</methodname> para
                    formar el string de la condición. </para>

            </note>

            <para> El segundo argumento del método
                    <methodname>where()</methodname> es opcional. Es un valor
                para sustituir en la expresión.
                    <classname>Zend_Db_Select</classname> entrecomilla el valor
                y lo sustituye por un signo de interrogación ("
                    <methodname>?</methodname> ") en la expresión. </para>

            <para>Este método acepta solo un parámetro. Si tiene una expresión
                en la cual necesita sustituir múltiples variables, deberá formar
                el string manualmente, interpolando variables y realizando
                entrecomillado manualmente.</para>

            <example id="zend.db.select.building.where.example-param">

                <title>Ejemplo de parámetro en el método where()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)

$minimumPrice = 100;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > ?', $minimumPrice);
]]></programlisting>

            </example>

            <para> You can pass an array as the second parameter to the
                    <methodname>where()</methodname> method when using the SQL
                IN operator. </para>

            <example id="zend.db.select.building.where.example-array">

                <title>Example of an array parameter in the where()
                    method</title>

                <programlisting language="php"><![CDATA[
// Build this query:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (product_id IN (1, 2, 3))

$productIds = array(1, 2, 3);

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('product_id IN (?)', $productIds);
]]></programlisting>

            </example>

            <para> You can invoke the <methodname>where()</methodname> method
                multiple times on the same <classname>Zend_Db_Select</classname>
                object. The resulting query combines the multiple terms together
                using <acronym>AND</acronym> between them. </para>

            <example id="zend.db.select.building.where.example-and">

                <title>Ejemplo de métodos where() múltiples</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)
//     AND (price < 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > ?', $minimumPrice)
             ->where('price < ?', $maximumPrice);
]]></programlisting>

            </example>

            <para> Si necesita combinar terminos usando <acronym>OR</acronym> ,
                use el método <methodname>orWhere()</methodname> . Este método
                se usa del mismo modo que el método
                    <methodname>where()</methodname> , excepto que el término
                especificado es precedido por <acronym>OR</acronym> , en lugar
                de <acronym>AND</acronym> . </para>

            <example id="zend.db.select.building.where.example-or">

                <title>Ejemplo del método orWhere()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00)
//     OR (price > 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price < ?', $minimumPrice)
             ->orWhere('price > ?', $maximumPrice);
]]></programlisting>

            </example>

            <para>
                <classname>Zend_Db_Select</classname> automáticamente pone
                paréntesis alrededor de cada expresión que especifique usando el
                método <methodname>where()</methodname> u
                    <methodname>orWhere()</methodname> . Esto ayuda a asegurar
                que la precedencia del operador Booleano no cause resultados
                inesperados. </para>

            <example id="zend.db.select.building.where.example-parens">

                <title>Ejemplos de Expresiones Booleanas con paréntesis</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00 OR price > 500.00)
//     AND (product_name = 'Apple')

$minimumPrice = 100;
$maximumPrice = 500;
$prod = 'Apple';

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where("price < $minimumPrice OR price > $maximumPrice")
             ->where('product_name = ?', $prod);
]]></programlisting>

            </example>

            <para> En el ejemplo anterior, los resultados deberían ser
                diferentes sin paréntesis, porque <acronym>AND</acronym> tiene
                precedencia más alta respecto a <acronym>OR</acronym> .
                    <classname>Zend_Db_Select</classname> aplica el parentesis
                con un efecto tal que la expresión en sucesivas llamadas al
                método <methodname>where()</methodname> vincula de forma más
                fuerte el <acronym>AND</acronym> que combina las expresiones. </para>

        </sect3>

        <sect3 id="zend.db.select.building.group">

            <title>Agregando una cláusula GROUP BY</title>

            <para> En <acronym>SQL</acronym> , la cláusula <command>GROUP
                    BY</command> permite reducir el número de filas del
                resultado de una consulta a una fila por cada valor único
                encontrado en la(s) columna(s) nombrada(s) en la cláusula
                    <command>GROUP BY</command> . </para>

            <para> En <classname>Zend_Db_Select</classname> , puede especificar
                la(s) columna(s) que usar para el cálculo de grupos de filas
                usando el método <methodname>group()</methodname> . El argumento
                de este método es una columna o un array de columnas que se
                usarán en la cláusula <command>GROUP BY</command> . </para>

            <example id="zend.db.select.building.group.example">

                <title>Ejemplo del método group()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id');
]]></programlisting>

            </example>

            <para> Como el array de columnas del método
                    <methodname>from()</methodname> , se puede usar correlación
                de nombres en el string de nombre de columna, y la columna será
                entrecomillada como un identificador, salvo que el string
                contenga paréntesis o sea un objeto de tipo
                    <classname>Zend_Db_Expr</classname> . </para>

        </sect3>

        <sect3 id="zend.db.select.building.having">

            <title>Agregando una cláusula HAVING</title>

            <para> En <acronym>SQL</acronym> , la cláusula
                    <constant>HAVING</constant> aplica una condición de
                restricción en grupos de filas. Es similar a una cláusula
                    <constant>WHERE</constant> aplicando una condición de
                restricción a las filas. Pero las 2 cláusulas son diferentes
                porque las condiciones <constant>WHERE</constant> son aplicadas
                antes que definan los grupos, mientras que las condiciones
                    <constant>HAVING</constant> son aplicadas después que los
                grupos son definidos. </para>

            <para> En <classname>Zend_Db_Select</classname> , puede especificar
                condiciones para restringir grupos usando el método
                    <methodname>having()</methodname> . Su uso es similar al del
                método <methodname>where()</methodname> . El primer agumento es
                un string conteniendo una expresión <acronym>SQL</acronym> . El
                segundo argumento es un valor que es usado para reemplazar un
                parámetro marcador de posición en la expresión
                    <acronym>SQL</acronym> . Las expresiones dadas en multiples
                invocaciones al método <methodname>having()</methodname> son
                combinadas usando el operador Booleano
                    <methodname>AND</methodname> , o el operador <code>OR</code>
                si usa el método <methodname>orHaving()</methodname> . </para>

            <example id="zend.db.select.building.having.example">

                <title>Ejemplo del método having()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   HAVING line_items_per_product > 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->having('line_items_per_product > 10');
]]></programlisting>

            </example>

            <note>

                <para> No se aplica entrecomillado a expresiones dadas al método
                        <methodname>having()</methodname> u
                        <methodname>orHaving()</methodname> . Si tiene nombres
                    de columnas que deban ser entrecomillados, deberá usar
                        <methodname>quoteIdentifier()</methodname> para formar
                    el string de la condición. </para>

            </note>

        </sect3>

        <sect3 id="zend.db.select.building.order">

            <title>Agregar una cláusula ORDER BY</title>

            <para> En <acronym>SQL</acronym> , la cláusula <code>ORDER BY</code>
                especifica una o más columnas o expresiones por el cual el
                resultado de la consulta será ordenado. Si multiples columnas
                son listadas, las columnas secundarias serán usadas para
                resolver relaciones; el orden de clasificación es determinado
                por columnas secundarias si la columna anterior contiene valores
                idénticos. El orden por defecto es del menor valor al mayor
                valor. Puede también ordenar de mayor a menor valor para una
                columna dada en la lista espeificando la palabra clave
                    <constant>DESC</constant> después de la columna. </para>

            <para> En <classname>Zend_Db_Select</classname> , puede usar el
                método <methodname>order()</methodname> para especificar una
                columna o un array de columnas por el cual ordenar. Cada
                elemento del array es un string nombrando la columna.
                Opcionalmente con la palabra reservada <constant>ASC</constant>
                o <constant>DESC</constant> siguiendola, separada por un
                espacio. </para>

            <para> Como en el método <methodname>from()</methodname> y
                    <methodname>group()</methodname> , los nombres de columnas
                son entrecomillados como identificadores, a menos que contengan
                paréntesis o sean un obheto de tipo
                    <classname>Zend_Db_Expr</classname> . </para>

            <example id="zend.db.select.building.order.example">

                <title>Ejemplo del método order()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   ORDER BY "line_items_per_product" DESC, "product_id"

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->order(array('line_items_per_product DESC',
                           'product_id'));
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.limit">

            <title>Agregando una cláusula LIMIT</title>

            <para> Algunos <acronym>RDBMS</acronym> extienden una consulta
                    <acronym>SQL</acronym> con una cláusula conocida como
                    <constant>LIMIT</constant> . Esta cláusuala reduce el número
                de filas en el resultado a no más de un número especificado.
                También puede especificar saltar el número de filas antes de
                empezar la salida. Esta característica hace más fácil tomar un
                subconjunto de resultados, por ejemplo cuando mostramos los
                resultados de una consulta en páginas progresivas de salida. </para>

            <para> En <classname>Zend_Db_Select</classname> , puede usar el
                método <methodname>limit()</methodname> para especificar la
                cantidad de filas y el número de filas que saltar. El
                    <emphasis>primer</emphasis> argumento es el método es el
                número de filas deseado. El <emphasis>segundo</emphasis>
                argument es el número de filas que saltar. </para>

            <example id="zend.db.select.building.limit.example">

                <title>Ejemplo del método limit()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20
// Equivalente  a:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 20 OFFSET 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limit(10, 20);
]]></programlisting>

            </example>

            <note>

                <para> La sintaxis de <constant>LIMIT</constant> no está
                    soportada por todos los <acronym>RDBMS</acronym> brands.
                    Algunos <acronym>RDBMS</acronym> requieren diferente
                    sintaxis para soportar una funcionalidad similar Cada clase
                        <classname>Zend_Db_Adapter_Abstract</classname> incluye
                    un método para producir el <acronym>SQL</acronym> apropiado
                    para cada <acronym>RDBMS</acronym> . </para>

            </note>

            <para> Use el método <methodname>limitPage()</methodname> como un
                modo alternativo de especificar la cantidad de filas y el
                offset. Este método permite limitar el conjunto resultado a una
                serie de subconjuntos de tamaño fijo de filas del total del
                resultado de la consulta. En otras palabras, puede especificar
                el tamaño de una "página" de resultados, y el número ordinal de
                la página simple donde se espera que devuelva la consulta. El
                número de página es el primer argumento del método
                    <methodname>limitPage()</methodname> , y la longitud de la
                página es el segundo argumento. Ambos son argumentos requeridos;
                no tienen valores por omisión. </para>

            <example id="zend.db.select.building.limit.example2">

                <title>Ejemplo del método limitPage()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limitPage(2, 10);
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.distinct">

            <title>Agregar el modificador DISTINCT a la consulta</title>

            <para> El método <methodname>distinct()</methodname> permite agregar
                la palabra clave a la consulta <constant>DISTINCT</constant> a
                su consulta <acronym>SQL</acronym> . </para>

            <example id="zend.db.select.building.distinct.example">

                <title>Ejemplo del método distinct()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT DISTINCT p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->distinct()
             ->from(array('p' => 'products'), 'product_name');
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.for-update">

            <title>Agregar el modificador FOR UPDATE</title>

            <para> El método <methodname>forUpdate()</methodname> permite
                agregar el modificador <code>FOR UPDATE</code> a su consulta
                    <acronym>SQL</acronym> . </para>

            <example id="zend.db.select.building.for-update.example">

                <title>Example of forUpdate() method</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT FOR UPDATE p.*
//   FROM "products" AS p

$select = $db->select()
             ->forUpdate()
             ->from(array('p' => 'products'));
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.union">
            <title>Building a UNION Query</title>

            <para> You can build union queries with
                    <classname>Zend_Db_Select</classname> by passing an array of
                    <classname>Zend_Db_Select</classname> or SQL Query strings
                into the <methodname>union()</methodname> method. As second
                parameter you can pass the
                    <constant>Zend_Db_Select::SQL_UNION</constant> or
                    <constant>Zend_Db_Select::SQL_UNION_ALL</constant> constants
                to specify which type of union you want to perform. </para>

            <example id="zend.db.select.building.union.example">
                <title>Example of union() method</title>

                <programlisting language="php"><![CDATA[
$sql1 = $db->select();
$sql2 = "SELECT ...";

$select = $db->select()
    ->union(array($sql1, $sql2))
    ->order("id");
]]></programlisting>
            </example>
        </sect3>

    </sect2>

    <sect2 id="zend.db.select.execute">

        <title>Ejecutando consultas Select</title>

        <para> En esta sección se describe cómo ejecutar una consulta
            representada por un objeto <classname>Zend_Db_Select</classname> . </para>

        <sect3 id="zend.db.select.execute.query-adapter">

            <title>Ejecutando Consultas SelectExecuting desde el Adaptador de
                Base de Datos</title>

            <para> Puede ejecutar la consulta representada por el objeto
                    <classname>Zend_Db_Select</classname> pasándolo como primer
                argumento al método <methodname>query()</methodname> de un
                objeto <classname>Zend_Db_Adapter_Abstract</classname> . Use
                objetos <classname>Zend_Db_Select</classname> en lugar de un
                string de consulta. </para>

            <para> El método <methodname>query()</methodname> devuelve un objeto
                de tipo <classname>Zend_Db_Statement</classname> o PDOStatement,
                dependiendo del tipo de adaptador. </para>

            <example id="zend.db.select.execute.query-adapter.example">

                <title>Ejemplo usando el método adaptador query() del Adaptador
                    de Base de datos</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $db->query($select);
$result = $stmt->fetchAll();
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.execute.query-select">

            <title>Ejecutando Consultas Select desde el Objeto</title>

            <para> Como alternativa al uso del método
                    <methodname>query()</methodname> del objeto adaptador, puede
                usar el método <methodname>query()</methodname> del objeto
                    <classname>Zend_Db_Select</classname> . Ambos métodos
                devuelven un objeto de tipo
                    <classname>Zend_Db_Statement</classname> o PDOStatement,
                dependiendo del tipo de adaptador. </para>

            <example id="zend.db.select.execute.query-select.example">

                <title>Ejempo usando el método query() del objeto Select</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $select->query();
$result = $stmt->fetchAll();
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.execute.tostring">

            <title> Convertiendo un Objeto Select a un String SQL</title>

            <para> Si necesita acceder a una represantación en un string de la
                consulta <acronym>SQL</acronym> correspondiente al objeto
                    <classname>Zend_Db_Select</classname> , use el método
                    <methodname>__toString()</methodname> . </para>

            <example id="zend.db.select.execute.tostring.example">

                <title>Ejemplo del método __toString()</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$sql = $select->__toString();
echo "$sql\n";

// La salida es el string:
//   SELECT * FROM "products"
]]></programlisting>

            </example>

        </sect3>

    </sect2>

    <sect2 id="zend.db.select.other">

        <title>Otros Métodos</title>

        <para> Esta sección describe otros métodos de
                <classname>Zend_Db_Select</classname> que no han sido cubiertos
            antes: <methodname>getPart()</methodname> y
                <methodname>reset()</methodname> . </para>

        <sect3 id="zend.db.select.other.get-part">

            <title>Obtener Partes de un Objeto Select</title>

            <para> El método <methodname>getPart()</methodname> devuelve una
                representación de una parte de su consulta
                    <acronym>SQL</acronym> . Por ejemplo, puede usar este método
                para devolver un array de expresiones para la cláusula
                    <constant>WHERE</constant> , o el array de columnas (o
                expresiones de columnas) que estan en la lista del
                    <constant>SELECT</constant> , o los valores de la cantidad y
                comienzo para la cláusula <constant>LIMIT</constant> . </para>

            <para> El valor de retorno no es un string conteniendo un fragmento
                de la sintaxis <acronym>SQL</acronym> . El valor de retorno es
                una representación, típicamente un array con una estructura que
                contiene valores y expresiones. Cada parte de la consulta tiene
                una estructura diferente. </para>

            <para> El único argumento del método
                    <methodname>getPart()</methodname> es un string que
                identifica qué parte del la consulta Select va a devolver. Por
                ejemplo, el string <code>'from'</code> identifica la parte del
                objeto Select que almacena la información de las tablas de la
                cláusula <constant>FROM</constant> , incluyendo uniones de
                tablas. </para>

            <para> La clase <classname>Zend_Db_Select</classname> define
                constantes que puedes usar para las partes de la consulta
                    <acronym>SQL</acronym> . Puede usar estas definiciones de
                constantes, o los strings literales. </para>

            <table id="zend.db.select.other.get-part.table">

                <title>Constantes usedas por getPart() y reset()</title>

                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Constante</entry>
                            <entry>Valor del String</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry>
                                <constant>Zend_Db_Select::DISTINCT</constant>
                            </entry>
                            <entry>
                                <code>'distinct'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::FOR_UPDATE</constant>
                            </entry>
                            <entry>
                                <code>'forupdate'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::COLUMNS</constant>
                            </entry>
                            <entry>
                                <code>'columns'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::FROM</constant>
                            </entry>
                            <entry>
                                <code>'from'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::WHERE</constant>
                            </entry>
                            <entry>
                                <code>'where'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::GROUP</constant>
                            </entry>
                            <entry>
                                <code>'group'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::HAVING</constant>
                            </entry>
                            <entry>
                                <code>'having'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::ORDER</constant>
                            </entry>
                            <entry>
                                <code>'order'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::LIMIT_COUNT</constant>
                            </entry>
                            <entry>
                                <code>'limitcount'</code>
                            </entry>
                        </row>

                        <row>
                            <entry>
                                <constant>Zend_Db_Select::LIMIT_OFFSET</constant>
                            </entry>
                            <entry>
                                <code>'limitoffset'</code>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <example id="zend.db.select.other.get-part.example">

                <title>Ejemplo del método getPart()</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products')
             ->order('product_id');

// Puede especificar un string literal para especificar la parte
$orderData = $select->getPart( 'order' );

// Puede usar una constante para especificar la misma parte
$orderData = $select->getPart( Zend_Db_Select::ORDER );

// El valor de retorno puede ser una estructura en un array, no un string.
// Cada parte tiene distinta estructura.
print_r( $orderData );
]]></programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.other.reset">

            <title>Restableciendo Partes de un Objeto</title>

            <para> El método <methodname>reset()</methodname> permite limpiar
                una parte específica de la consulta <acronym>SQL</acronym> , o
                limpia todas las partes de la consulta <acronym>SQL</acronym> si
                omite el argumento. </para>

            <para> El argumento es opcional. Puede especificar la parte de la
                consulta que será limpiada, usando los mismos strings que usa el
                argumento del método <methodname>getPart()</methodname> . La
                parte de la consulta que especifique se reestablecerá a su
                estado por omisión. </para>

            <para> Si omite el parámetro, <methodname>reset()</methodname>
                cambia todas las partes de la consulta a su estado por omisión.
                Esto hace que el objeto <classname>Zend_Db_Select</classname>
                sea equivalente a crear un nuevo objeto, como si acabase de
                instanciarlo. </para>

            <example id="zend.db.select.other.reset.example">

                <title>Ejemplo del método reset()</title>

                <programlisting language="php"><![CDATA[
// Construya esta consulta:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_name"

$select = $db->select()
             ->from(array('p' => 'products')
             ->order('product_name');

// Requisito cambiado, en su lugar un orden diferente de columnas:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_id"

// Limpia una parte para poder redefinirla
$select->reset( Zend_Db_Select::ORDER );

// Y especificar una columna diferente
$select->order('product_id');

// Limpia todas las partes de la consulta
$select->reset();
]]></programlisting>

            </example>

        </sect3>

    </sect2>

</sect1>

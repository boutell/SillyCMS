<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<sect1 id="zend.filter.introduction">

    <title>Введение</title>

    <para>
        Компонента <classname>Zend_Filter</classname> предоставляет набор наиболее часто используемых
        фильтров данных. Она также предоставляет простой механизм формирования
        цепочек фильтров данных, с использованием которого одни и те же
        данные могут обрабатываться несколькими фильтрами в порядке, заданном
        пользователем.
    </para>

    <sect2 id="zend.filter.introduction.definition">

        <title>Что есть фильтр?</title>

        <para>
            В материальном мире фильтр обычно используется для удаления
            нежелательных частей ввода. Желаемые части ввода проходят сквозь
            фильтр и являются выводом фильтра. В таких сценариях фильтр
            является опрератором, который выделяет подмножество ввода. Этот
            тип фильтра полезен для веб-приложений - удаление недопустимого
            ввода, лишних пробельных символов и т.д.
        </para>
    
        <para>
            Это базовое определение фильтра может быть расширено включением
            общих преобразований ввода. Часто встречающееся в веб-приложениях
            преобразование - экранирование сущностей HTML (HTML entities).
            Например, если поле формы автоматически заполняется ненадежными
            данными (например, данными из веб-броузера), то это значение не
            должно включать в себя сущности HTML, либо эти сущности должны
            быть экранированы, для предотвращения нежелательного поведения
            и угроз безопасности. В соответствии с этими требованиями сущности
            HTML должны быть удалены или экранированы - выбор подхода зависит
            от ситуации. Фильтр, который экранирует сущности HTML, тем не
            менее, преобразовывает ввод (например, "<code>&amp;</code>"
            преобразовывается в "<code>&amp;amp;</code>"). Поддержка таких
            случаев использования важна для веб-разработчиков и "фильтрация"
            в контексте использования <classname>Zend_Filter</classname> подразумевает выполнение
            некоторых преобразований над входными данными.
        </para>

    </sect2>

    <sect2 id="zend.filter.introduction.using">

        <title>Основы использования фильтров</title>

        <para>
            Такое определение фильтра дает основу для
            <classname>Zend_Filter_Interface</classname>, который требует
            от классов фильтров реализации одного метода с именем
            <code>filter()</code>.
        </para>
    
        <para>
            Ниже приведен пример использования фильтра с двумя вариантами
            входных данных - амперсандом (<code>&amp;</code>) и двойными
            кавычками (<code>&quot;</code>).
            
            <programlisting language="php"><![CDATA[
$htmlEntities = new Zend_Filter_HtmlEntities();

echo $htmlEntities->filter('&'); // &amp;
echo $htmlEntities->filter('"'); // &quot;
]]></programlisting>

    </para>

    </sect2>
    
    <sect2 id="zend.filter.introduction.static">

        <title>Использование статического метода get()</title>

        <para>
            Каждый раз загружать нужный класс фильтра и создавать его экземпляр
            довольно неудобно, поэтому был создан статический метод
            <code>Zend_Filter::get()</code>, который можно использовать как
            альтернативный способ вызова.
            Первым агрументом этого метода является значение входных данных,
            которое требуется передать методу <code>filter()</code>. Вторым
            аргументом является строка, которая соответствует базовому имени
            класса фильтра относительно пространства имен <classname>Zend_Filter</classname>.
            Метод <code>get()</code> автоматически загружает класс,
            создает его экземпляр и применяет метод <code>filter()</code> к
            входным данным.

            <programlisting language="php"><![CDATA[
echo Zend_Filter::get('&', 'HtmlEntities');
]]></programlisting>

        </para>

        <para>
            Можно также передавать массив аргументов для конструктора, если это
            необходимо для используемого класса фильтра.

            <programlisting language="php"><![CDATA[
echo Zend_Filter::get('"', 'HtmlEntities', array(ENT_QUOTES));
]]></programlisting>

        </para>

        <para>
            Использование метода <code>get()</code> может быть удобным для
            единичного вызова фильтра. Но если нужно пропустить через один и
            тот же фильтр несколько значений, то более эффективным будет
            создавать экземпляр фильтра и вызывать его метод
            <code>filter()</code>, как это было показано в первом примере.
        </para>

        <para>
            <classname>Zend_Filter_Input</classname> также позволяет инстанцировать и запускать
            несколько фильтров и валидаторов для обработки наборов
            данных. Более подробную информацию читайте в
            <xref linkend="zend.filter.input" />.
        </para>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<sect1 id="zend.cache.frontends">
    <title>Фронтэнды Zend_Cache</title>

    <sect2 id="zend.cache.frontends.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.frontends.core.introduction">
            <title>Введение</title>
            <para>
                Фронтэнд <classname>Zend_Cache_Core</classname> является особым,
                так как это ядро всего модуля. Это фронтэнд общего назначения и
                он расширяется другими классами.
            </para>
            <note>
                <para>
                    Все фронтэнды наследуют от класса
                    <classname>Zend_Cache_Core</classname>, поэтому его методы и опции,
                    описанные ниже, должны быть доступны в других фронтэндах и
                    не будут описываться далее.
                </para>
            </note>
        </sect3>
        <sect3 id="zend.cache.frontends.core.options">
            <title>Доступные опции</title>
            <para>
                Эти опции передаются фабричному методу, как было показано в
                предыдущих примерах.
            </para>
            <table id="zend.cache.frontends.core.options.table">
                <title>Опции Zend_Cache_Core</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Опция</entry>
                            <entry>Тип данных</entry>
                            <entry>Значение по умолчанию</entry>
                            <entry>Описание</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><emphasis>caching</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>TRUE</constant></entry>
                              <entry>
                                  Включает/отключает кэширование (может быть
                                  очень полезным при отладке кэшируемых
                                  скриптов).
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>cache_id_prefix</emphasis></entry>
                              <entry><type>String</type></entry>
                              <entry><constant>NULL</constant></entry>
                              <entry>
                                  Префикс для всех идентификаторов кэша. Если
                                  установлен в <constant>NULL</constant>, то префикс не
                                  будет использоваться. Префикс идентификатора
                                  кэша в первую очередь создает пространство
                                  имен в кэше, что позволяет нескольким
                                  приложениям или веб-сайтам использовать общий
                                  кэш. Любое приложение или веб-сайт может
                                  использовать свой префикс идентификаторов
                                  кэша, благодаря чему отдельные идентификаторы
                                  кеша могут использоваться многократно.
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>lifetime</emphasis></entry>
                              <entry><type>Integer</type></entry>
                              <entry>3600</entry>
                              <entry>
                                Время жизни кэша (в секундах), если установлен в
                                <constant>NULL</constant>, то кэш имеет бесконечное
                                время жизни.
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>logging</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>FALSE</constant></entry>
                              <entry>
                                 Если установлен в <constant>TRUE</constant>, то
                                 включается логирование через
                                 <classname>Zend_Log</classname> (но система будет
                                 работать медленнее).
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>write_сontrol</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>TRUE</constant></entry>
                              <entry>
                                Включает/отключает контроль записи (кэш
                                читается сразу после записи для выявления
                                поврежденных записей), включение write_control
                                немного замедлит запись кэша, но не чтение. Этот
                                контроль поможет выявить некоторые поврежденные
                                файлы кэша, но не является совершенным.
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>automatic_serialization</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>FALSE</constant></entry>
                              <entry>
                                Включает/отключает автоматическую
                                сериализацию, она может использоваться для
                                сохранения напрямую данных, которые не являются
                                строками (но это будет медленнее).
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>automatic_cleaning_factor</emphasis></entry>
                              <entry><type>Integer</type></entry>
                              <entry>10</entry>
                              <entry>
                                Отключает/настраивает процесс автоматической
                                очистки (сборки мусора):
                                0 означает, что автоматическая
                                чистка кэша не производится,
                                1 означает систематическую очистку
                                кэша,
                                x (integer) &gt; 1 означает, что
                                автоматическая чистка производится случайным
                                образом 1 раз на x записей кэша.
                              </entry>
                          </row>
                          <row>
                              <entry><emphasis>ignore_user_abort</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>FALSE</constant></entry>
                              <entry>
                                  Если установлен в true, то ядро будет
                                  устанавливать <acronym>PHP</acronym>-флаг
                                  ignore_user_abort в методе
                                  save() во избежание порчи кэша в некоторых
                                  случаях.
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Примеры</title>
            <para>
                Пример был дан в самом начале данного раздела руководства.
            </para>
            <para>
                Если вы храните в кэше только строки (с опцией
                <emphasis>automatic_serialization</emphasis> возможно хранить некоторые
                булевы значения), вы можете использовать более компактную
                конструкцию, как показано ниже:
            </para>
            <programlisting language="php"><![CDATA[
// предполагается, что переменная $cache уже установлена

$id = 'myBigLoop'; // идентификатор того, что мы хотим закэшировать

if (!($data = $cache->load($id))) {
    // промах кэша

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// [...] делаем что-либо с данными (отображение, передача и т.д.)
]]></programlisting>
            <para>
                Если вы хотите закэшировать несколько блоков или экземпляров
                данных, то принцип будет тот же:
            </para>
            <programlisting language="php"><![CDATA[
// убедитесь, что используете уникальные идентификаторы:
$id1 = 'foo';
$id2 = 'bar';

// блок 1
if (!($data = $cache->load($id1))) {
    // промах кэша

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// эта часть не кэшируется
echo('НЕ КЭШИРУЕТСЯ! ');

// блок 2
if (!($data = $cache->load($id2))) {
    // промах кэша

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);]]></programlisting>
            <para>
                Если вы хотите кэшировать специальные значения (булево
                значение через опцию "automatic_serialization") или пустую
                строку, то компактная форма, приведенная выше, уже не
                подходит. Проверка на наличие записи кэша должна производиться
                созданным для этого методом.
            </para>
            <programlisting language="php"><![CDATA[
// Копмпактная форма. Не подходит, если могут кэшироваться
// пустые строки и значения булевого типа
if (!($data = $cache->load($id))) {

    // промах кэша

    // [...] получаем данные и присваиваем их переменной $data

    $cache->save($data);

}

// делаем что-либо с данными

// [...]

// Полная форма, будет работать в любом случае
if (!($cache->test($id))) {

    // промах кэша

    // [...] получаем данные и присваиваем их переменной $data

    $cache->save($data);

} else {

    // попадание в кэш

    $data = $cache->load($id);

}

// делаем что-либо с данными
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontends.output.introduction">
            <title>Введение</title>
            <para>
                <classname>Zend_Cache_Frontend_Output</classname> является фронтэндом,
                собирающим выходные данные. Он использует буферизацию вывода
                (output buffering) в <acronym>PHP</acronym> для сохранения
                всего, что выводится между его методами
                <methodname>start()</methodname> и <methodname>end()</methodname>.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.output.options">
            <title>Доступные опции</title>
            <para>
                Этот фронтэнд не имеет каких-либо специальных опций, отличных
                от опций <classname>Zend_Cache_Core</classname>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.examples">
            <title>Примеры</title>
            <para>
                Пример был дан в самом начале данного руководства. Здесь
                он с небольшими изменениями:
            </para>
            <programlisting language="php"><![CDATA[
// если имеет место промах кэша,
// то начинается буферизация вывода
if (!($cache->start('mypage'))) {

    // все выводится, как обычно
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';

    $cache->end(); // завершение буферизации вывода

}

echo 'This is never cached ('.time().').';
]]></programlisting>
            <para>
                Используя эту форму, довольно легко установить кэширование
                вывода в уже работающем проекте с незначительным рефакторингом
                кода или совсем без него.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontends.function.introduction">
            <title>Введение</title>
            <para>
                <classname>Zend_Cache_Frontend_Function</classname> сохраняет в кэш
                результаты вызова функции. Он имеет единственный основной метод
                <methodname>call()</methodname>, который принимает имя функции и параметры
                вызова в виде массива.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.function.options">
            <title>Доступные опции</title>
            <table id="zend.cache.frontends.function.options.table">
                <title>Опции Zend_Cache_Frontend_Function</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Опция</entry>
                            <entry>Тип данных</entry>
                            <entry>Значение по умолчанию</entry>
                            <entry>Описание</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><emphasis>cache_by_default</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>TRUE</constant></entry>
                              <entry>
                                  Если равен true, то вызовы функции по
                                  умолчанию кэшируются.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>cached_functions</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry></entry>
                              <entry>
                                  Имена функций, которые всегда кэшируются.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>non_cached_functions</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry></entry>
                              <entry>
                                  Имена функций, которые никогда не должны
                                  кэшироваться.
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontends.function.examples">
            <title>Примеры</title>
            <para>
                Функция <methodname>call()</methodname> используется так же, как и
                <methodname>call_user_func_array()</methodname> в
                <acronym>PHP</acronym>:
            </para>
            <programlisting language="php"><![CDATA[
$cache->call('veryExpensiveFunc', $params);

// $params является массивом
// Например, если нужно вызвать с кэшированием
// veryExpensiveFunc(1, 'foo', 'bar'),
// то вы должны использовать
// $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'))
]]></programlisting>
            <para>
                <classname>Zend_Cache_Frontend_Function</classname> достаточно
                интеллектуален, чтобы кэшировать как возвращаемое функцией
                значение, так и данные, выводимые внутри нее.
            </para>
            <note>
                <para>
                    Вы можете передавать любые как встроенные, так и
                    определенные пользователем функции, за исключением
                    <methodname>array()</methodname>,
                    <methodname>echo()</methodname>, <methodname>empty()</methodname>,
                    <methodname>eval()</methodname>, <methodname>exit()</methodname>,
                    <methodname>isset()</methodname>, <methodname>list()</methodname>,
                    <methodname>print()</methodname> и <methodname>unset()</methodname>.
                </para>
            </note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontends.class.introduction">
            <title>Введение</title>
            <para>
                <classname>Zend_Cache_Frontend_Class</classname> отличается от
                <classname>Zend_Cache_Frontend_Function</classname> тем, что позволяет
                кэшировать объекты и статические вызовы методов.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.class.options">
            <title>Доступные опции</title>
            <table id="zend.cache.frontends.class.options.table">
                <title>Опции Zend_Cache_Frontend_Class</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Опция</entry>
                            <entry>Тип данных</entry>
                            <entry>Значение по умолчанию</entry>
                            <entry>Описание</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><emphasis>cached_entity</emphasis> (required)</entry>
                              <entry><type>Mixed</type></entry>
                              <entry></entry>
                              <entry>
                                  Если установлен как имя класса, то будет
                                  кэшироваться абстрактный класс и будут
                                  использоваться только статические вызовы; если
                                  установлен как объект,
                                  то будут кэшироваться методы объекта.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>cache_by_default</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>TRUE</constant></entry>
                              <entry>
                                  Если установлен в <constant>TRUE</constant>, то вызовы
                                  будут кэшироваться по умолчанию.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>cached_methods</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry></entry>
                              <entry>
                                  Имена методов, которые должны всегда
                                  кэшироваться.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>non_cached_methods</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry></entry>
                              <entry>
                                  Имена методов, которые никогда не должны
                                  кэшироваться.
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontends.class.examples">
            <title>Примеры</title>
            <para>
                Кэширование статических вызовов:
            </para>
            <programlisting language="php"><![CDATA[<?php
class Test {

    // Статический метод
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => 'Test' // имя класса
);
// [...]

// Кэшируемый вызов
$result = $cache->foobar('1', '2');
]]></programlisting>
            <para>
                Кэширование обычных вызовов методов:
            </para>
            <programlisting language="php"><![CDATA[
class Test {

    private $_string = 'hello !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => new Test() // экземпляр класса
);
// [...]

// Кэшируемый вызов
$result = $cache->foobar2('1', '2');
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Введение</title>
            <para>
                <classname>Zend_Cache_Frontend_File</classname> является фронтэндом,
                который управляется временем изменения "ведущего файла".
                Он очень полезен для кэширования конфигураций или шаблонов.
                Можно использовать несколько ведущих файлов.
            </para>
            <para>
                Например, у вас есть конфигурационный файл
                <acronym>XML</acronym>. Он парсится
                функцией, которая возвращает объект конфигурации
                (наподобие <classname>Zend_Config</classname>). С помощью
                <classname>Zend_Cache_Frontend_File</classname> вы можете сохранять объект
                конфигурации в кэш, чтобы избежать повторного парсинга
                конфигурационного файла <acronym>XML</acronym>. Время жизни
                кэша будет зависеть от ведущего файла - если конфигурационный
                файл <acronym>XML</acronym> изменится, то кэш сразу становится
                недействительным.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Доступные опции</title>
            <table id="zend.cache.frontends.file.options.table">
                <title>Опции Zend_Cache_Frontend_File</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Опция</entry>
                            <entry>Тип данных</entry>
                            <entry>Значение по умолчанию</entry>
                            <entry>Описание</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><emphasis>master_file</emphasis>
                                  (не рекомендуется к использованию)</entry>
                              <entry><type>String</type></entry>
                              <entry>''</entry>
                              <entry>
                                  Полные путь и имя ведущего файла
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>master_files</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry><methodname>array()</methodname></entry>
                              <entry>
                                  Массив полных путей к ведущим файлам
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>master_files_mode</emphasis></entry>
                              <entry><type>String</type></entry>
                              <entry><constant>Zend_Cache_Frontend_File::MODE_OR</constant></entry>
                              <entry>
                                  <constant>Zend_Cache_Frontend_File::MODE_AND</constant> или <constant>Zend_Cache_Frontend_File::MODE_OR</constant>;
                                  если <constant>MODE_AND</constant>, то все ведущие файлы должны быть изменены для того, чтобы кэш стал недействительным
                                  если <constant>MODE_OR</constant>, то достаточно изменения одного ведущего файла, чтобы кэш стал недействительным
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>ignore_missing_master_files</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>FALSE</constant></entry>
                              <entry>
                                  если равен <constant>TRUE</constant>, то отсутствующие
                                  ведущие файлы игнорируются, иначе бросается
                                  исключение
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Примеры</title>
            <para>
                Этот фронтэнд используется так же, как и
                <classname>Zend_Cache_Core</classname>. Специальные примеры не нужны,
                единственное, что надо сделать — это указать
                <emphasis>masterFile</emphasis> при использовании фабрики.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
        <title>Zend_Cache_Frontend_Page</title>
        <sect3 id="zend.cache.frontends.page.introduction">
            <title>Введение</title>
            <para>
                <classname>Zend_Cache_Frontend_Page</classname> похож на
                <classname>Zend_Cache_Frontend_Output</classname>,
                но предназначена для кэширования целых страниц.
                <classname>Zend_Cache_Frontend_Page</classname>
                нельзя использовать для кэширования отдельных блоков.
            </para>
            <para>
                Идентификатор кэша вычисляется автоматически
                с использованием <varname>$_SERVER['REQUEST_URI']</varname> и
                (в зависимости от опций) <varname>$_GET</varname>,
                <varname>$_POST</varname>, <varname>$_SESSION</varname>,
                <varname>$_COOKIE</varname>, <varname>$_FILES</varname>.
                Кроме этого, вы используете только один метод для вызова
                (<methodname>start()</methodname>), потому что
                <methodname>end()</methodname> вызывается
                автоматически, когда страница заканчивается.
            </para>
            <para>
                На данный момент мы планируем добавить условную систему
                <acronym>HTTP</acronym> для
                сохранения пропускной способности (система будет отправлять
                <acronym>HTTP</acronym> 304 Not Modified, если есть попадание
                в кэш и броузер уже имеет правильную версию страницы).
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.page.options">
            <title>Доступные опции</title>
            <table id="zend.cache.frontends.page.options.table">
                <title>Опции Zend_Cache_Frontend_Page</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Опция</entry>
                            <entry>Тип данных</entry>
                            <entry>Значение по умолчанию</entry>
                            <entry>Описание</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><emphasis>http_conditional</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>FALSE</constant></entry>
                              <entry>
                                  Использовать условную систему HTTP (не
                                  реализовано на данный момент)
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>debug_header</emphasis></entry>
                              <entry><type>Boolean</type></entry>
                              <entry><constant>FALSE</constant></entry>
                              <entry>
                                  Если установлен в <constant>TRUE</constant>, то
                                  отладочный текст вставляется перед каждой
                                  кэшируемой страницей.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>default_options</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry><methodname>array(...смотрите далее...)</methodname></entry>
                              <entry>
                                  Ассоциативный массив опций, включаемых по
                                  умолчанию:
                                  <itemizedlist>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, true</emphasis> по
                                              умолчанию) <emphasis>cache</emphasis>:
                                              если <constant>TRUE</constant>, то
                                              кэширование включено
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, false</emphasis> по
                                              умолчанию)
                                              <emphasis>cache_with_get_variables</emphasis>:
                                              если <constant>TRUE</constant>, кэширование
                                              включено, даже если в массиве
                                              <varname>$_GET</varname> есть переменные
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, false</emphasis> по
                                              умолчанию)
                                              <emphasis>cache_with_post_variables</emphasis>:
                                              если <constant>TRUE</constant>, кэширование
                                              включено, даже если в массиве
                                              <varname>$_POST</varname> есть переменные
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, false</emphasis> по
                                              умолчанию)
                                              <emphasis>cache_with_session_variables</emphasis>:
                                              если <constant>TRUE</constant>, кэширование
                                              включено, даже если в массиве
                                              <varname>$_SESSION</varname> есть
                                              переменные
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, false</emphasis> по
                                              умолчанию)
                                              <emphasis>cache_with_files_variables</emphasis>:
                                              если <constant>TRUE</constant>, кэширование
                                              включено, даже если в массиве
                                              <varname>$_FILES</varname> есть переменные
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, false</emphasis> по
                                              умолчанию)
                                              <emphasis>cache_with_cookie_variables</emphasis>:
                                              если <constant>TRUE</constant>, кэширование
                                              включено, даже если в массиве
                                              <varname>$_COOKIE</varname> есть
                                              переменные
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, true</emphasis> по
                                              умолчанию)
                                              <emphasis>make_id_with_get_variables</emphasis>:
                                              если <constant>TRUE</constant>, то
                                              идентификатор кэша будет зависеть
                                              от содержимого массива
                                              <varname>$_GET</varname>
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, true</emphasis> по
                                              умолчанию)
                                              <emphasis>make_id_with_post_variables</emphasis>:
                                              если <constant>TRUE</constant>, то
                                              идентификатор кэша будет зависеть
                                              от содержимого массива
                                              <varname>$_POST</varname>
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, true</emphasis> по
                                              умолчанию)
                                              <emphasis>make_id_with_session_variables</emphasis>:
                                              если <constant>TRUE</constant>, то
                                              идентификатор кэша будет зависеть
                                              от содержимого массива
                                              <varname>$_SESSION</varname>
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, true</emphasis> по
                                              умолчанию)
                                              <emphasis>make_id_with_files_variables</emphasis>:
                                              если <constant>TRUE</constant>, то
                                              идентификатор кэша будет зависеть от
                                              содержимого массива
                                              <varname>$_FILES</varname>
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>boolean, true</emphasis> по
                                              умолчанию)
                                              <emphasis>make_id_with_cookie_variables</emphasis>:
                                              если <constant>TRUE</constant>, то
                                              идентификатор кэша будет зависеть от
                                              содержимого массива
                                              <varname>$_COOKIE</varname>
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>int, false</emphasis> по
                                              умолчанию)
                                              <emphasis>specific_lifetime</emphasis>:
                                              если не <constant>FALSE</constant>,
                                              то значение этой опции,
                                              обозначающей время жизни кэша,
                                              будет использоваться для выбранного
                                              регулярного выражения
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>array, array()</emphasis> по
                                              умолчанию)
                                              <emphasis>tags</emphasis>:
                                              теги для записи в кэше
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              (<emphasis>int, null</emphasis> по
                                              умолчанию)
                                              <emphasis>priority</emphasis>:
                                              приоритет. Действует только
                                              если выбранный бэкэнд поддерживает
                                              приоритеты.
                                          </para>
                                      </listitem>
                                  </itemizedlist>
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>regexps</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry><methodname>array()</methodname></entry>
                              <entry>
                                  Ассоциативный массив для установки опций
                                  только для некоторых
                                  <acronym>REQUEST_URI</acronym>. Ключами
                                  этого массива являются регулярные выражения
                                  (<acronym>PCRE</acronym>), значениями —
                                  ассоциативные массивы со
                                  специальными опциями, которые устанавливаются,
                                  если <varname>$_SERVER['REQUEST_URI']</varname>
                                  соответствует регулярному выражению
                                  (см. default_options в этом списке доступных
                                  опций). Если <varname>$_SERVER['REQUEST_URI']</varname>
                                  соответствует нескольким регулярным
                                  выражениям, то используется только последнее
                                  из них.
                              </entry>
                         </row>
                         <row>
                              <entry><emphasis>memorize_headers</emphasis></entry>
                              <entry><type>Array</type></entry>
                              <entry><methodname>array()</methodname></entry>
                              <entry>
                                   Массив строк с именами
                                   <acronym>HTTP</acronym>-заголовков.
                                   Перечисленные заголовки будут сохранены в
                                   кэше и будут замещены при попадании в кэш.
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.page.examples">
            <title>Примеры</title>
            <para>
                Использование <classname>Zend_Cache_Frontend_Page</classname> довольно
                простое:
            </para>
            <programlisting language="php"><![CDATA[
// [...]

$cache->start();
// если есть попадание в кэш, то результат отправляется броузеру
// и выполнение скрипта на этом прекращается

// остальная часть страницы ...
]]></programlisting>
            <para>
                Более сложный пример, показывающий способ создания
                централизованного управления кэшированием в загрузочном файле
                (например, для использования с <classname>Zend_Controller</classname>).
            </para>
            <programlisting language="php"><![CDATA[
/*
 * Вы должны избегать слишком большого количества строк кода перед этим участком
 * кэша. Например, для наибольшей производительности "require_once" или
 * "Zend_Loader::loadClass" должны находиться после кэшируемого участка
 */

$frontendOptions = array(
   'lifetime' => 7200,
   'debug_header' => true, // для отладки
   'regexps' => array(
       // кэширование всего IndexController
       '^/$' => array('cache' => true),

       // кэширование всего IndexController
       '^/index/' => array('cache' => true),

       // не кэшируем ArticleController...
       '^/article/' => array('cache' => false),

       // ...но кэшируем действие "view" контроллера ArticleController
       '^/article/view/' => array(
           'cache' => true,

           // кэшируем, даже если есть переменные $_POST
           'cache_with_post_variables' => true,

           // но кэш будет зависеть от массива $_POST
           'make_id_with_post_variables' => true,
       )
   )
);

$backendOptions = array(
    'cache_dir' => '/tmp/'
);

// получение объекта Zend_Cache_Frontend_Page
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache->start();
// если есть попадание в кэш, результат отправляется броузеру,
// и выполнение скрипта на этом завершается

// [...] конец загрузочного файла
// (этот код не исполняется, если есть попадание в кэш)
]]></programlisting>
        </sect3>
        <sect3 id="zend.cache.frontends.page.cancel">
            <title>Отмена кэширования</title>
            <para>
                В некоторых случаях может потребоваться отменить текущий
                процесс кэширования - например, если используется код
                возврата, отличный от <acronym>HTTP</acronym> 200. Поэтому
                мы добавили метод <methodname>cancel()</methodname>:
            </para>
            <programlisting language="php"><![CDATA[
// [...]

$cache->start();

// [...]

if ($someTest) {
    $cache->cancel();
    // [...]
}

// [...]
]]></programlisting>
        </sect3>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->

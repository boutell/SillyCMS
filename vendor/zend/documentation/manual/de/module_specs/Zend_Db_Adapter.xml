<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 21877 -->
<!-- Reviewed: no -->
<sect1 id="zend.db.adapter">
    <title>Zend_Db_Adapter</title>

    <para>
        <classname>Zend_Db</classname> und die zugehörigen Klassen bieten eine einfache
        <acronym>SQL</acronym> Schnittstelle für Zend Framework.
        <classname>Zend_Db_Adapter</classname> ist die Basisklasse zur Anbindung einer
        <acronym>PHP</acronym> Anwendung an ein <acronym>RDBMS</acronym>. Es gibt für jede
        <acronym>RDBMS</acronym> Marke einen eigenen Adapter.
    </para>

    <para>
        Die <classname>Zend_Db</classname> Adapter bilden eine Schnittstelle zu den Hersteller
        spezifischen <acronym>PHP</acronym> Erweiterungen und unterstützen dadurch die Entwicklung
        einer <acronym>PHP</acronym> Anwendung für verschiedene <acronym>RDBMS</acronym> mit
        geringem Aufwand.
    </para>

    <para>
        Die Schnittstellen der Adapterklasse ähneln denen der
        <ulink url="http://www.php.net/pdo">PHP Data Objects</ulink> Erweiterung.
        <classname>Zend_Db</classname> bietet Adapterklassen für <acronym>PDO</acronym> Treiber der
        folgenden <acronym>RDBMS</acronym> Marken:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                <acronym>IBM</acronym> <acronym>DB2</acronym> und Informix Dynamic Server
                (<acronym>IDS</acronym>), verwenden die <ulink
                    url="http://www.php.net/pdo-ibm">pdo_ibm</ulink> <acronym>PHP</acronym>
                Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                MySQL, verwendet die <ulink url="http://www.php.net/pdo-mysql">pdo_mysql</ulink>
                <acronym>PHP</acronym> Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                Microsoft <acronym>SQL</acronym> Server, verwendet die <ulink
                    url="http://www.php.net/pdo-dblib">pdo_dblib</ulink> <acronym>PHP</acronym>
                Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                Oracle, verwendet die <ulink url="http://www.php.net/pdo-oci">pdo_oci</ulink>
                <acronym>PHP</acronym> Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                PostgreSQL, verwendet die <ulink
                    url="http://www.php.net/pdo-pgsql">pdo_pgsql</ulink> <acronym>PHP</acronym>
                Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                SQLite, verwendet die <ulink url="http://www.php.net/pdo-sqlite">pdo_sqlite</ulink>
                <acronym>PHP</acronym> Erweiterung
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Zusätzlich bietet <classname>Zend_Db</classname> Adapterklassen für die folgenden
        <acronym>RDBMS</acronym> Marken, welche eigene <acronym>PHP</acronym> Datenbank
        Erweiterungen nutzen:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                MySQL, mit der <ulink url="http://www.php.net/mysqli">mysqli</ulink>
                <acronym>PHP</acronym> Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                Oracle, mit der <ulink url="http://www.php.net/oci8">oci8</ulink>
                <acronym>PHP</acronym> Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                <acronym>IBM</acronym> <acronym>DB2</acronym> und <acronym>DB2</acronym> I5, mit der
                <ulink url="http://www.php.net/ibm_db2">ibm_db2</ulink> <acronym>PHP</acronym>
                Erweiterung
            </para>
        </listitem>

        <listitem>
            <para>
                Firebird (Interbase), mit der <ulink
                    url="http://www.php.net/ibase">php_interbase</ulink> <acronym>PHP</acronym>
                Erweiterung
            </para>
        </listitem>
    </itemizedlist>

    <note>
        <para>
            Jeder <classname>Zend_Db</classname> Adapter nutzt eine <acronym>PHP</acronym>
            Erweiterung. Die entsprechend <acronym>PHP</acronym> Erweiterung muss in der
            <acronym>PHP</acronym> Umgebung aktiviert sein um den <classname>Zend_Db</classname>
            Adapter zu nutzen. Zum Beispiel muss bei der Nutzung eines <acronym>PDO</acronym>
            <classname>Zend_Db</classname> Adapters sowohl die <acronym>PDO</acronym> Erweiterung,
            als auch der <acronym>PDO</acronym> Treiber für die jeweilige <acronym>RDBMS</acronym>
            Marke geladen sein.
        </para>
    </note>

    <sect2 id="zend.db.adapter.connecting">
        <title>Anbindung einer Datenbank mit einem Adapter</title>

        <para>
            Dieser Abschnitt beschreibt wie eine Instanz eines Datenbankadapters erzeugt wird. Dies
            entspricht der Erzeugung einer Verbindung an ein <acronym>RDBMS</acronym> Server in
            einer <acronym>PHP</acronym> Anwendung.
        </para>

        <sect3 id="zend.db.adapter.connecting.constructor">
            <title>Nutzung des Zend_Db Adapter Konstruktors</title>

            <para>
                Man kann eine Instanz eines Adapters erzeugen, indem man den Konstruktor verwendet.
                Ein Adapter Konstruktur benötigt ein Argument, wobei es sich um ein Array mit
                Parametern für die Verbindung handelt.
            </para>

            <example id="zend.db.adapter.connecting.constructor.example">
                <title>Nutzung eines Adapter Konstruktors</title>

                <programlisting language="php"><![CDATA[
$db = new Zend_Db_Adapter_Pdo_Mysql(array(
    'host'     => '127.0.0.1',
    'username' => 'webuser',
    'password' => 'xxxxxxxx',
    'dbname'   => 'test'
));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.connecting.factory">
            <title>Nutzung der Zend_Db Factory</title>

            <para>
                Als Alternative zur direkten Nutzung des Konstruktors kann man auch eine Instanz des
                Adapters erzeugen indem man die statische Methode
                <methodname>Zend_Db::factory()</methodname> nutzt. Diese Methode lädt die
                Adapterklasse dynamisch bei Aufruf unter Nutzung von <link
                    linkend="zend.loader.load.class">Zend_Loader::loadClass()</link>.
            </para>

            <para>
                Das erste Argument ist ein String der den Namen der Adapterklasse enthält. Zum
                Beispiel entspricht der String '<classname>Pdo_Mysql</classname>' der Klasse
                <classname>Zend_Db_Adapter_Pdo_Mysql</classname>. Das zweite Argument ist das
                gleiche Array von Parametern wie bei der Verwendung des Adapter Konstruktors.
            </para>

            <example id="zend.db.adapter.connecting.factory.example">
                <title>Nutzung der Adapter factory() Methode</title>

                <programlisting language="php"><![CDATA[
// Wir benötigen das folgende Statement nicht da die
// Zend_Db_Adapter_Pdo_Mysql Datei für uns durch die Factory
// Methode von Zend_Db geladen wird

// require_once 'Zend/Db/Adapter/Pdo/Mysql.php';

// Lädt automatisch die Klasse Zend_Db_Adapter_Pdo_Mysql
// und erzeugt eine Instanz von Ihr.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'     => '127.0.0.1',
    'username' => 'webuser',
    'password' => 'xxxxxxxx',
    'dbname'   => 'test'
));
]]></programlisting>
            </example>

            <para>
                Wenn eine eigene Klasse geschrieben wird, die
                <classname>Zend_Db_Adapter_Abstract</classname> erweitert aber nicht mit
                dem Präfix "<classname>Zend_Db_Adapter</classname>" beginnt, kann die
                <methodname>factory()</methodname> Methode verwendet werden um den Adapter zu
                Laden wenn der führende Teil der Adapter Klasse mit dem 'adapterNamespace'
                Schlüssel im Parameter Array spezifiziert wird.
            </para>

            <example id="zend.db.adapter.connecting.factory.example2">
                <title>Die factory Methode für eine eigene Adapter Klasse verwenden</title>

                <programlisting language="php"><![CDATA[
// Wir müssen die Datei der Adapter Klasse nicht laden
// weil Sie für uns durch die Factory Methode von Zend_Db geladen wird

// Die MyProject_Db_Adapter_Pdo_Mysql Klasse automatisch laden
// und eine Instanz von Ihr erstellen.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'             => '127.0.0.1',
    'username'         => 'webuser',
    'password'         => 'xxxxxxxx',
    'dbname'           => 'test',
    'adapterNamespace' => 'MyProject_Db_Adapter'
));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.connecting.factory-config">
            <title>Zend_Config mit Zend_Db_Factory verwenden</title>

            <para>
                Optional kann jedes Argument der <methodname>factory()</methodname> Methode als
                Objekt des Typs <link linkend="zend.config">Zend_Config</link> spezifiziert werden.
            </para>

            <para>
                Wenn das erste Argument ein Config Objekt ist, wird erwartet das es eine Eigenschaft
                enthält die <property>adapter</property> heißt und einen String enthält der nach dem
                Adapter Basis Klassen Namen benannt ist. Optional kann das Objekt eine Eigenschaft
                genannt <property>params</property> enthalten, mit Subeigenschaften korrespondierend
                zu den Parameter Namen des Adapters. Das wird nur verwendet wenn das zweite Argument
                für die <methodname>factory()</methodname> Methode nicht angegeben wird.
            </para>

            <example id="zend.db.adapter.connecting.factory.example1">
                <title>
                    Verwenden der Factory Methode des Adapters mit einem Zend_Config Objekt
                </title>

                <para>
                    Im Beispiel anbei wird ein <classname>Zend_Config</classname> Objekt von einem
                    Array erstellt. Die Daten können auch aus einer externen Datei geladen werden
                    indem Klassen wie zum Beispiel <link
                        linkend="zend.config.adapters.ini">Zend_Config_Ini</link> oder <link
                        linkend="zend.config.adapters.xml">Zend_Config_Xml</link> verwendet werden.
                </para>

                <programlisting language="php"><![CDATA[
$config = new Zend_Config(
    array(
        'database' => array(
            'adapter' => 'Mysqli',
            'params'  => array(
                'host'     => '127.0.0.1',
                'dbname'   => 'test',
                'username' => 'webuser',
                'password' => 'secret',
            )
        )
    )
);

$db = Zend_Db::factory($config->database);
]]></programlisting>
            </example>

            <para>
                Das zweite Argument der <methodname>factory()</methodname> Methode kann ein
                assoziatives Array sein das Einträge enthält die den Parameters des Adapters
                entsprechen. Dieses Argument ist optional. Wenn das erste Argument vom Typ
                <classname>Zend_Config</classname> ist, wird angenommen das es alle Parameter
                enthält, und das zweite Argument wird ignoriert.
            </para>
        </sect3>

        <sect3 id="zend.db.adapter.connecting.parameters">
            <title>Adapter Parameter</title>

            <para>
                Die folgende Liste erklärt die gemeinsamen Parameter die von
                <classname>Zend_Db</classname> Adapterklassen erkannt werden.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>host</emphasis>: Ein String der den Hostname oder die Ip-Adresse
                        des Datenbankservers beinhaltet. Wenn die Datenbank auf dem gleichen Host
                        wie die <acronym>PHP</acronym> Anwendung läuft wird 'localhost' oder
                        '127.0.0.1' verwendet.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>username</emphasis>: Konto Kennung zur Authentisierung einer
                        Verbindung zum <acronym>RDBMS</acronym> Server.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>password</emphasis>: Konto Passwort zur Authentisierung einer
                        Verbindung zum <acronym>RDBMS</acronym> Server.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>dbname</emphasis>: Datenbank Name auf dem <acronym>RDBMS</acronym>
                        Server.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>port</emphasis>: Einige <acronym>RDBMS</acronym> Server können
                        Netzwerkverbindungen an vom Administrator spezifizierten Ports akzeptieren.
                        Der Port-Parameter gibt die Möglichkeit die Portnummer anzugeben, an welche
                        die <acronym>PHP</acronym> Anwendung verbindet um der Port-Konfiguration des
                        <acronym>RDBMS</acronym> Servers zu entsprechen.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>charset</emphasis>: Spezifiziert das Zeichenset das für diese
                        Verbindung verwendet werden soll.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>options</emphasis>: Dieser Parameter ist ein assoziatives Array
                        von Optionen die in allen <classname>Zend_Db_Adapter</classname> Klassen
                        enthalten sind.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>driver_options</emphasis>: Dieser Parameter ist ein assoziatives
                        Array von zusätzlichen Optionen die spezifisch für die angegebene
                        Datenbankerweiterung sind. Eine typische Anwendung dieses Parameters ist,
                        Attribute für einen <acronym>PDO</acronym> Treiber zu setzen.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>adapterNamespace</emphasis>: Benennt den führenden Teil des
                        Klassen Namens für den Adapter statt
                        '<classname>Zend_Db_Adapter</classname>'. Dies kann verwendet werden wenn
                        man die <methodname>factory()</methodname>Methode verwenden muß um eine
                        nicht von Zend kommende Datenbank Adapter Klasse zu laden.
                    </para>
                </listitem>
            </itemizedlist>

            <example id="zend.db.adapter.connecting.parameters.example1">
                <title>Übergeben der case-folding Option an die factory</title>

                <para>
                    Diese Option kann über die Konstante
                    <constant>Zend_Db::CASE_FOLDING</constant> angegeben werden. Sie entspricht
                    dem <constant>ATTR_CASE</constant> Attribut in <acronym>PDO</acronym> und
                    <acronym>IBM</acronym> <acronym>DB2</acronym> Datenbanktreibern und stellt die
                    Schreibweise von String Schlüsseln in Abfrageergebnissen ein. Die Option kann
                    den Wert <constant>Zend_Db::CASE_NATURAL</constant> (der Standard),
                    <constant>Zend_Db::CASE_UPPER</constant> oder
                    <constant>Zend_Db::CASE_LOWER</constant> annehmen.
                </para>

                <programlisting language="php"><![CDATA[
$options = array(
    Zend_Db::CASE_FOLDING => Zend_Db::CASE_UPPER
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'options'        => $options
);

$db = Zend_Db::factory('Db2', $params);
]]></programlisting>
            </example>

            <example id="zend.db.adapter.connecting.parameters.example2">
                <title>Übergeben der auto-quoting Option an die factory</title>

                <para>
                    Diese Option kann über die Konstante
                    <constant>Zend_Db::AUTO_QUOTE_IDENTIFIERS</constant> angegeben werden. Wenn
                    der Wert <constant>TRUE</constant> (der Standard) ist, werden Bezeichner wie
                    Tabellennamen, Spaltennamen und auch Aliase in jeder <acronym>SQL</acronym>
                    Syntax die vom Adapter Objekt generiert wurde begrenzt. Dies macht es einfach
                    Bezeichner zu verwenden, die <acronym>SQL</acronym> Schlüsselwörter oder
                    spezielle Zeichen enthalten. Wenn der Wert <constant>FALSE</constant> ist,
                    werden Bezeichner nicht automatisch begrenzt. Wenn Bezeichner begrenzt werden
                    müssen, so kann dies über die <methodname>quoteIdentifier()</methodname> Methode
                    von Hand getan werden.
                </para>

                <programlisting language="php"><![CDATA[
$options = array(
    Zend_Db::AUTO_QUOTE_IDENTIFIERS => false
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'options'        => $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
]]></programlisting>
            </example>

            <example id="zend.db.adapter.connecting.parameters.example3">
                <title>Übergeben von PDO Treiber Optionen an die factory</title>

                <programlisting language="php"><![CDATA[
$pdoParams = array(
    PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => true
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'driver_options' => $pdoParams
);

$db = Zend_Db::factory('Pdo_Mysql', $params);

echo $db->getConnection()
        ->getAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY);
]]></programlisting>
            </example>

            <example id="zend.db.adapter.connecting.parameters.example4">
                <title>Übergabe einer Serialisierungs Option an die Factory</title>

                <programlisting language="php"><![CDATA[
$options = array(
    Zend_Db::ALLOW_SERIALIZATION => false
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'options'        => $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.connecting.getconnection">
            <title>Verwalten von Lazy Connections</title>

            <para>
                Die Erzeugung einer Instanz der Adapterklasse stellt nicht gleichzeitig eine
                Verbindung zum <acronym>RDBMS</acronym> her. Der Adapter speichert die
                Verbindungsparameter und stellt die tatsächliche Verbindung bei Bedarf her, wenn die
                erste Anfrage ausgeführt wird. Dies stellt sicher, dass die Erzeugung eines
                Adapterobjekts schnell und sparsam ist. Dadurch kann auch dann eine Instanz eines
                Adapters erzeugt werden, wenn nicht zwingend eine Datenbankanfrage für die aktuell
                gelieferte Darstellung der Anwendung benötigt wird.
            </para>

            <para>
                Wenn der Adapter zwingend eine Verbindung zum <acronym>RDBMS</acronym> herstellen
                soll, kann die <methodname>getConnection()</methodname> Methode verwendet werden.
                Diese liefert ein Objekt der Verbindung, welches eine Verbindung entsprechend der
                verwendeten <acronym>PHP</acronym> Erweiterung repräsentiert. Wenn zum Beispiel
                irgendeine der <acronym>PDO</acronym> Adapterklassen verwendet wird, dann liefert
                <methodname>getConnection()</methodname> das <acronym>PDO</acronym> Object, nachdem
                es als eine live Verbindung zu der entsprechenden Datenbank initialisiert wurde.
            </para>

            <para>
                Es kann nützlich sein eine Verbindung zu erzwingen um jegliche Exceptions
                abzufangen, die als Resultat falscher Konto Berechtigungen oder einem anderen Fehler
                bei der Verbindung zum <acronym>RDBMS</acronym> auftreten. Diese Exceptions treten
                nicht auf, bis die tatsächliche Verbindung hergestellt ist, daher kann es den
                Anwendungs-Code vereinfachen, wenn diese Exceptions an einer Stelle bearbeitet
                werden, und nicht erst bei der ersten Anfrage.
            </para>

            <para>
                Zusätzlich kann ein Adapter serialisiert werden um Ihn zu speichern, zum Beispiel in
                einer Session Variable. Das kann sehr nütlich sein, nicht nur für den Adapter
                selbst, sondern auch für andere Objekte die Ihn verwenden, wie ein
                <classname>Zend_Db_Select</classname> Objekt. Standardmäßig, ist es Adaptern erlaubt
                serialisiert zu werden. Wenn man das nicht will, sollte man die
                <constant>Zend_Db::ALLOW_SERIALIZATION</constant> Option mit
                <constant>FALSE</constant> übergeben, wie im
                Beispiel anbei gezeigt. Um das Prinzip von Lazy Connections zu erlauben, wird der
                Adapter sich selbst nicht wiederverbinden wenn er deserialisiert wird. Man muß
                <methodname>getConnection()</methodname> selbst aufrufen. Mann kann den Adapter
                dazu bringen sich automatisch wieder zu verbinden indem
                <constant>Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE</constant> als Option mit
                <constant>TRUE</constant> zum Adapter übergeben wird.
            </para>

            <example
                id="zend.db.adapter.connecting.getconnection.example">
                <title>Umgang mit Verbindungs Exceptions</title>

                <programlisting language="php"><![CDATA[
try {
    $db = Zend_Db::factory('Pdo_Mysql', $parameters);
    $db->getConnection();
} catch (Zend_Db_Adapter_Exception $e) {
    // Möglicherweise ein fehlgeschlagener login,
    // oder die RDBMS läuft möglicherweise nicht
} catch (Zend_Exception $e) {
    // Möglicherweise kann factory() die definierte Adapter Klasse nicht laden
}
]]></programlisting>
            </example>
        </sect3>
    </sect2>

    <sect2 id="zend.db.adapter.example-database">
        <title>Beispiel Datenbank</title>

        <para>
            In der Dokumentation für die <classname>Zend_Db</classname> Klassen verwenden wir einige
            einfache Tabellen um die Verwendung der Klassen und Methoden zu erläutern. Diese
            Beispieltabellen können Informationen für das Bugtracking in einem Softwareprojekt
            speichern. Die Datenbank enthält vier Tabellen:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis>accounts</emphasis> speichert Informationen über jeden Benutzer des
                    Bugtracking Systems.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>products</emphasis> speichert Informationen über jedes Produkt für das
                    ein Bug erfasst werden kann.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>bugs</emphasis> speichert informationen über Bugs, dazu gehört der
                    derzeitige Status des Bugs, die Person die den Bug berichtet hat, die Person die
                    den Bug beheben soll und die Person welche die Fehlerbehebung verifizieren soll.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>bugs_products</emphasis> speichert Beziehungen zwischen Bugs und
                    Produkten. Dies enthält eine Viele-zu-Viele Beziehung, da ein Bug für mehrere
                    Produkte relevant sein kann. Und natürlich kann ein Produkt auch mehrere Bugs
                    enthalten.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Der folgende <acronym>SQL</acronym> Daten Definitions Sprache Pseudocode beschreibt die
            Tabellen in dieser Beispieldatenbank. Diese Beispieltabellen werden intensiv bei den
            automatisierten Unit-Tests für <classname>Zend_Db</classname> verwendet.
        </para>

        <programlisting language="sql"><![CDATA[
CREATE TABLE accounts (
account_name      VARCHAR(100) NOT NULL PRIMARY KEY
);

CREATE TABLE products (
product_id        INTEGER NOT NULL PRIMARY KEY,
product_name      VARCHAR(100)
);

CREATE TABLE bugs (
bug_id            INTEGER NOT NULL PRIMARY KEY,
bug_description   VARCHAR(100),
bug_status        VARCHAR(20),
reported_by       VARCHAR(100) REFERENCES accounts(account_name),
assigned_to       VARCHAR(100) REFERENCES accounts(account_name),
verified_by       VARCHAR(100) REFERENCES accounts(account_name)
);

CREATE TABLE bugs_products (
bug_id            INTEGER NOT NULL REFERENCES bugs,
product_id        INTEGER NOT NULL REFERENCES products,
PRIMARY KEY       (bug_id, product_id)
);
]]></programlisting>

        <para>
            Weiterhin zu beachten ist, dass die 'bugs' Tabelle mehrere Foreign-Key
            References zu der 'accounts' Tabelle enthält. Jeder dieser Foreign-Keys kann
            auf eine andere Zeile für einen angegebenen Bug in der 'accounts' Tabelle
            verweisen.
        </para>

        <para>
            Das unten stehende Diagramm illustriert das physische Datenmodell der Beispieldatenbank.
        </para>

        <para>
            <inlinegraphic width="387" scale="100" align="center" valign="middle"
                fileref="figures/zend.db.adapter.example-database.png" format="PNG" />
        </para>
    </sect2>

    <sect2 id="zend.db.adapter.select">
        <title>Lesen von Abfrageergebnissen</title>

        <para>
            Dieser Abschnitt beschreibt Methoden der Adapterklasse mit denen
            <acronym>SELECT</acronym> Abfragen ausgeführt werden können um Abfrageergebnisse
            abzurufen.
        </para>

        <sect3 id="zend.db.adapter.select.fetchall">
            <title>Holen des kompletten Ergebnisssatzes</title>

            <para>
                Man kann eine <acronym>SQL</acronym> <acronym>SELECT</acronym> Anfrage ausführen
                und alle Ergebnisse auf einmal mit der <methodname>fetchAll()</methodname> Methode
                abrufen.
            </para>

            <para>
                Das erste Argument dieser Methode ist ein String der die <acronym>SELECT</acronym>
                Anweisung enthält. Als Alternative kann das erste Argument auch ein Objekt der
                <link linkend="zend.db.select">Zend_Db_Select</link> Klasse sein. Der Adapter
                konvertiert dieses automatisch in einen String der die <acronym>SELECT</acronym>
                Anweisung repräsentiert.
            </para>

            <para>
                Das zweite Argument von <methodname>fetchAll()</methodname> ist ein Array von
                Werten die Parameterplatzhalter in der <acronym>SQL</acronym> Anweisung ersetzen.
            </para>

            <example id="zend.db.adapter.select.fetchall.example">
                <title>Nutzung von fetchAll()</title>

                <programlisting language="php"><![CDATA[
$sql = 'SELECT * FROM bugs WHERE bug_id = ?';

$result = $db->fetchAll($sql, 2);
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetch-mode">
            <title>Ändern des Fetch Modus</title>

            <para>
                Standardmäßig gibt <methodname>fetchAll()</methodname> ein Array von Zeilen, jede
                als assoziatives Array, zurück. Die Schlüssel von diesem assoziativem Array
                entsprechen den Spalten oder Spaltenaliasen wie sie in der SELECT Anfrage benannt
                sind.
            </para>

            <para>
                Man kann einen anderen Stil für das Holen der Ergebnisse mit der
                <methodname>setFetchMode()</methodname> Methode angeben. Die unterstützten Modi
                werden mit folgenden Konstanten identifiziert:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis><constant>Zend_Db::FETCH_ASSOC</constant></emphasis>: Gibt Daten
                        in einem assoziativem Array zurück. Die Array Schlüssel sind Strings der
                        Spaltennamen. Dies ist der Standardmodus für
                        <classname>Zend_Db_Adapter</classname> Klassen.
                    </para>

                    <para>
                        Zu beachten ist, dass wenn die Select-Liste mehr als eine Spalte mit dem
                        selben Namen enthält, zum Beispiel wenn diese aus verschiedenen Tabellen
                        durch einem <acronym>JOIN</acronym> bestehen, kann nur einer der Einträge
                        im assoziativem Array enthalten sein. Wenn der
                        <constant>FETCH_ASSOC</constant> Modus verwandt wird, sollten Spaltenaliase
                        in der <acronym>SELECT</acronym> Anfrage angegeben werden um sicherzustellen
                        dass die Namen eindeutige Arrayschlüssel ergeben.
                    </para>

                    <para>
                        Standardmäßig werden die Strings so zurück gegeben wie sie von dem
                        Datenbanktreiber geliefert werden. Dies entspricht der typischen
                        Schreibweise der Spaltennamen auf dem <acronym>RDBMS</acronym> Server. Die
                        Schreibweise dieser Strings kann mit der
                        <constant>Zend_Db::CASE_FOLDING</constant> Option angegeben werden. Dies
                        muss bei der Instanziierung des Adapters angegeben werden. Beschreibung
                        unter <link linkend="zend.db.adapter.connecting.parameters.example1">dieses
                            Beispiel</link>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis><constant>Zend_Db::FETCH_NUM</constant></emphasis>: Gibt Daten in
                        einem Array von Arrays zurück. Die Arrays werden über Integer indiziert,
                        entsprechend der Position der betreffenden Felder in der Select-Liste der
                        Anfrage.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis><constant>Zend_Db::FETCH_BOTH</constant></emphasis>: Gibt ein
                        Array von Arrays zurück. Die Arrayschlüssel sind sowohl Strings wie beim
                        <constant>FETCH_ASSOC</constant> Modus, als auch Integer wie beim
                        <constant>FETCH_NUM</constant> modus. Zu beachten ist, dass die Anzahl der
                        Elemente in dem Array doppelt so groß ist, als wenn
                        <constant>FETCH_ASSOC</constant> oder <constant>FETCH_NUM</constant>
                        verwendet worden wäre.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis><constant>Zend_Db::FETCH_COLUMN</constant></emphasis>: Gibt Daten
                        in einem Array von Werten zurück. Die Werte in jedem Array sind die Werte
                        wie sie in einer Spalte des Ergebnisses zurück gegeben wurden. Standardmäßig
                        ist die erste Spalte mit 0 indiziert.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis><constant>Zend_Db::FETCH_OBJ</constant></emphasis>: Gibt Daten in
                        einem Array von Objekten zurück. Die Standardklasse ist die in
                        <acronym>PHP</acronym> eingebaute Klasse stdClass. Spalten des Ergebnisses
                        sind als öffentliche Eigenschaften des Objekts verfügbar.
                    </para>
                </listitem>
            </itemizedlist>

            <example id="zend.db.adapter.select.fetch-mode.example">
                <title>Nutzung von setFetchMode()</title>

                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchAll('SELECT * FROM bugs WHERE bug_id = ?', 2);

// $result ist ein Array von Objekten
echo $result[0]->bug_description;
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchassoc">
            <title>Holen eines Ergbnisssatzes als assoziatives Array</title>

            <para>
                Die <methodname>fetchAssoc()</methodname> Methode gibt Daten in einem Array von
                assoziativen Array zurück, egal welcher Wert für den fetch-Modus gesetzt wurde,
                indem die erste Spalte als Array Index verwendet wird.
            </para>

            <example id="zend.db.adapter.select.fetchassoc.example">
                <title>Nutzung von fetchAssoc()</title>

                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchAssoc(
    'SELECT bug_id, bug_description, bug_status FROM bugs'
);

// $result ist ein Array von assoziativen Arrays im Geist von fetch mode
echo $result[2]['bug_description']; // Beschreibung von Fehler #2
echo $result[1]['bug_description']; // Beschreibung von Fehler #1
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchcol">
            <title>Holen einer einzelnen Spalte eines Ergebnisssatzes</title>

            <para>
                Die <methodname>fetchCol()</methodname> Methode gibt Daten in einem Array von
                Werten zurück, egal welcher Wert für den fetch-Modus gesetzt wurde. Sie gibt nur
                die erste Spalte der Anfrage zurück. Alle weiteren Spalten der Anfrage werden
                verworfen. Wenn eine andere Spalte als die Erste benötigt wird sollte
                <link linkend="zend.db.statement.fetching.fetchcolumn">dieser Abschnitt</link>
                beachtet werden.
            </para>

            <example id="zend.db.adapter.select.fetchcol.example">
                <title>Nutzung von fetchCol()</title>

                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchCol(
    'SELECT bug_description, bug_id FROM bugs WHERE bug_id = ?', 2);

// Enthält bug_description; bug_id wird nicht zurückgegeben
echo $result[0];
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchpairs">
            <title>Holen von Schlüssel-Wert Paaren eines Ergebnisssatzes</title>

            <para>
                Die <methodname>fetchPairs()</methodname> Methode gibt Daten in einem Array von
                Schlüssel-Wert Paaren zurück, einem assoziativen Array mit einem einzelnen Eintrag
                pro Zeile. Der Schlüssel dieses assoziativen Arrays wird von der ersten Spalte des
                SELECT Ergebnisses genommen. Der Wert wird aus der zweiten Spalte des SELECT
                Ergebnisses genommen. Alle weiteren Spalten des Ergebnisses werden verworfen.
            </para>

            <para>
                Die <acronym>SELECT</acronym> Anfrage sollte so gestaltet sein, dass die erste
                Spalte nur eindeutige Werte liefert. Wenn doppelte Werte in der ersten Spalte
                vorkommen, werden entsprechende Einträge in dem assoziativen Array überschrieben.
            </para>

            <example id="zend.db.adapter.select.fetchpairs.example">
                <title>Nutzung von fetchPairs()</title>

                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchAssoc('SELECT bug_id, bug_status FROM bugs');

echo $result[2];
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchrow">
            <title>Holen einer einzelnen Zeile eines Ergebnisssatzes</title>

            <para>
                Die <methodname>fetchRow()</methodname> Methode gibt Daten entsprechend dem
                fetch-Modus zurück, jedoch nur die erste Zeile des Ergebnisssatzes.
            </para>

            <example id="zend.db.adapter.select.fetchrow.example">
                <title>Nutzung von fetchRow()</title>

                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchRow('SELECT * FROM bugs WHERE bug_id = 2');

// Beachte das $result ein einzelnes Objekt ist, und kein Array von Objekten
echo $result->bug_description;
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchone">
            <title>Holen eines einzelnen Scalars aus einem Ergebnisssatz</title>

            <para>
                Die <methodname>fetchOne()</methodname> Methode ist wie eine Kombination von
                <methodname>fetchRow()</methodname> mit <methodname>fetchCol()</methodname>, gibt
                also nur die erste Zeile des Ergebnisssatze zurück, und von dieser auch nur den
                Wert der ersten Spalte. Daher wird nur ein einziger scalarer Wert zurückgegeben,
                kein Array und auch kein Objekt.
            </para>

            <example id="zend.db.adapter.select.fetchone.example">
                <title>Nutzung von fetchOne()</title>

                <programlisting language="php"><![CDATA[
$result = $db->fetchOne('SELECT bug_status FROM bugs WHERE bug_id = 2');

// this is a single string value
echo $result;
]]></programlisting>
            </example>
        </sect3>
    </sect2>

    <sect2 id="zend.db.adapter.write">
        <title>Schreiben von Änderungen in die Datenbank</title>

        <para>
            Die Adapterklasse kann verwendet werden um neue Daten in die Datenbank zu schreiben oder
            bestehende Daten in der Datenbank zu ändern. Dieser Abschnitt beschreibt Methoden für
            diese Operationen.
        </para>

        <sect3 id="zend.db.adapter.write.insert">
            <title>Einfügen von Daten</title>

            <para>
                Neue Zeilen können in die Datenbank mit der <methodname>insert()</methodname>
                Methode eingefügt werden. Das erste Argument ist ein String der die Tabelle
                benennt, und das zweite Argument ist ein assoziatives Array das den Spaltennamen
                Datenwerte zuordnet.
            </para>

            <example id="zend.db.adapter.write.insert.example">
                <title>Einfügen in eine Tabelle</title>

                <programlisting language="php"><![CDATA[
$data = array(
    'created_on'      => '2007-03-22',
    'bug_description' => 'Etwas falsch',
    'bug_status'      => 'NEW'
);

$db->insert('bugs', $data);
]]></programlisting>
            </example>

            <para>
                Spalten die nicht in dem Array definiert sind, werden nicht an die Datenbank
                übergeben. Daher folgen sie den selben Regeln denen eine <acronym>SQL</acronym>
                <acronym>INSERT</acronym> Anweisung folgt: wenn die Spalte eine
                <acronym>DEFAULT</acronym> Klausel hat, so bekommt die Spalte der neuen Zeile diesen
                Wert. Andernfalls behält sie den Status <constant>NULL</constant>.
            </para>

            <para>
                Standardmäßig werden die Daten in dem Array mit Parametern eingefügt. Dies reduziert
                das Risiko einiger Typen von Sicherheitsproblemen. Die Werte in dem Array müssen
                daher nicht escaped oder quotiert übergeben werden.
            </para>

            <para>
                Einige Werte in dem Array könnten als <acronym>SQL</acronym> Expressions benötigt
                werden, in diesem Fall dürfen sie nicht in Anführungszeichen stehen. Standardmäßig
                werden alle übergebenen String-Werte als String-literale behandelt. Um anzugeben das
                ein Wert eine <acronym>SQL</acronym> Expression ist, und daher nicht quotiert werden
                soll, muss der Wert als ein Objekt des Typs <classname>Zend_Db_Expr</classname>
                übergeben werden, und nicht als einfacher String.
            </para>

            <example id="zend.db.adapter.write.insert.example2">
                <title>Einfügen von Expressions in eine Tabelle</title>

                <programlisting language="php"><![CDATA[
$data = array(
    'created_on'      => new Zend_Db_Expr('CURDATE()'),
    'bug_description' => 'Etwas falsch',
    'bug_status'      => 'NEW'
);

$db->insert('bugs', $data);
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.write.lastinsertid">
            <title>Abfragen von generierten Werten</title>

            <para>
                Einige <acronym>RDBMS</acronym> Marken unterstützen Auto-Incrementierung von
                Primärschlüsseln. Eine Tabelle die so definiert ist generiert automatisch einen
                Primärschlüsselwert während des <acronym>INSERT</acronym>'s einer neuen Zeile. Der
                Rückgabewert der <methodname>insert()</methodname> Methode ist
                <emphasis>nicht</emphasis> die letzte eingefügte ID, weil die Tabelle keine
                Auto-Increment Spalte haben könnte. Statt dessen ist der Rückgabewert die Anzahl der
                betroffenen Zeilen (normalerweise 1).
            </para>

            <para>
                Wenn die Tabelle mit einem Auto-Increment Primärschlüssel definiert ist, kann die
                <methodname>lastInsertId()</methodname> Methode nach dem INSERT aufgerufen werden.
                Diese Methode gibt den letzten generierten Wertim Rahmen der aktuellen
                Datenbankverbindung zurück.
            </para>

            <example id="zend.db.adapter.write.lastinsertid.example-1">
                <title>Nutzung von lastInsertId() für einen Auto-Increment Schlüssel</title>

                <programlisting language="php"><![CDATA[
$db->insert('bugs', $data);

// Gib den letzten durch eine auto-inkrement Spalte erzeugten Wert zurück
$id = $db->lastInsertId();
]]></programlisting>
            </example>

            <para>
                Einige <acronym>RDBMS</acronym> Marken unterstützen ein Sequenz-Objekt, welches
                eindeutige Werte generiert, die als Primärschlüsselwerte dienen. Um Sequenzen zu
                unterstützen, akzeptiert die <methodname>lastInsertId()</methodname> Method zwei
                optionale String Argumente. Diese Argumente benennen die Tabelle und die Spalte, in
                der Annahme das die Konvention beachtet wurde, dass eine Sequenz mit der Tabelle und
                der Spalte benannt wurde, für die sie Werte generiert plus dem Anhang "_seq". Dies
                basiert auf der Konvention die von PostgreSQL verwendet wird, wenn Sequenzen für
                <acronym>SERIAL</acronym> Spalten benannt werden. Zum Beispiel würde eine Tabelle
                "bugs" mit der Primärschlüsselspalte "bug_id" eine Sequenz als "bugs_bug_id_seq"
                benennen.
            </para>

            <example id="zend.db.adapter.write.lastinsertid.example-2">
                <title>Nutzung von lastInsertId() für eine Sequenz</title>

                <programlisting language="php"><![CDATA[
$db->insert('bugs', $data);

// Gib den letzten durch die 'bugs_bug_id_seq' Sequenz erstellten Wert zurück
$id = $db->lastInsertId('bugs', 'bug_id');

// Gib, alternativ, den letzten durch die 'bugs_seq' Sequenz
// erstellten Wert zurück
$id = $db->lastInsertId('bugs');
]]></programlisting>
            </example>

            <para>
                Wenn der Name des Squenz-Objekts nicht dieser Konvention folgt muss die
                <methodname>lastSequenceId()</methodname> Methode an Stelle verwendet werden. Diese
                Methode benötigt ein String Argument, welches die Sequenz wörtlich benennt.
            </para>

            <example id="zend.db.adapter.write.lastinsertid.example-3">
                <title>Nutzung von lastSequenceId()</title>

                <programlisting language="php"><![CDATA[
$db->insert('bugs', $data);

// Gib den letzten durch die 'bugs_id_gen' Sequenz erstellten Wert zurück.
$id = $db->lastSequenceId('bugs_id_gen');
]]></programlisting>
            </example>

            <para>
                Bei <acronym>RDBMS</acronym> Marken die keine Sequenzen unterstützen, dazu gehören
                MySQL, Microsoft <acronym>SQL</acronym> Server und SQLite, werden die Argumente an
                die <methodname>lastInsertId()</methodname> Methode ignoriert, und der zurück
                gegebene Wert ist der zuletzt für eirgendeine Tabelle während einer
                <acronym>INSERT</acronym> Operation generierte Wert innerhalb der aktuellen
                Verbindung. Für diese <acronym>RDBMS</acronym> Marken gibt die
                <methodname>lastSequenceId()</methodname> Methode immer <constant>NULL</constant>
                zurück.
            </para>

            <note>
                <title>Weshalb sollte man nicht "SELECT MAX(id) FROM table" verwenden?</title>

                <para>
                    Manchmal gibt diese Anfrage den zuletzt eingefügten Primärschlüsselwert zurück.
                    Trotzdem ist diese Technik in einer Umgebung in der mehrere Clients Daten in die
                    Datenbank einfügen nicht sicher. Es ist möglich, und daher vorherbestimmt
                    eventuell aufzutreten, das ein anderer Client in dem Augenblick zwischen dem
                    INSERT deiner Client Anwendung und deiner Anfrage für den
                    <methodname>MAX(id)</methodname> Wert, eine andere Zeile einfügt. Somit
                    identifiziert der zurück gegebene Wert nicht die von dir eingefügte Zeile,
                    sondern die eines anderen Clients. Man kann nie wissen wann dies passiert.
                </para>

                <para>
                    Das Nutzen eines starken Transaktions Isolationsmodus wie "repeatable read" kann
                    das Risiko mindern, aber einige <acronym>RDBMS</acronym> Marken unterstützen
                    nicht die Transaktions Isolation die hierfür benötigt wird, oder deine
                    Applikation könnte einen schwächeren Transaktions Isolationsmodus nutzen.
                </para>

                <para>
                    Darüberhinaus ist das Nutzen eins Ausdrucks wie "<command>MAX(id)+1</command>"
                    um einen neuen Wert für den Primärschlüssel zu generiern nict sicher, weil zwei
                    Clients diese Anfrage gleichzeitig ausführen könnten und damit beide den
                    gleichen Wert für ihre nächste <acronym>INSERT</acronym> Operation bekommen
                    würden.
                </para>

                <para>
                    Alle <acronym>RDBMS</acronym> Marken bieten einen Mechanismus um eindeutige
                    Werte zu generieren, und um den zuletzt generierten Wert zurück zu geben. Diese
                    Machanismen funktionieren notwendigerweise außerhalb des Gültigkeitsbereichs
                    einer Transaktions Isolation, es besteht daher nicht die Möglichkeit das zwei
                    Clients den selben Wert generieren und es besteht nicht die Möglichkeit das der
                    Wert, der von einem anderen Client generiert wurde, an die Verbindung deines
                    Clients, als letzter generierter Wert, gesendet wird.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.db.adapter.write.update">
            <title>Aktualisieren von Daten</title>

            <para>
                Zeilen in der Datenbank können mit der <methodname>update()</methodname> Methode
                eines Adapters aktualisiert werden. Diese Methode benötigt drei Argumente: Das
                Erste ist der Name der Tabelle und das Zweite ist ein assoziatives Array das den zu
                Ändernden Spalten neue Werte zuordnet.
            </para>

            <para>
                Die Werte des Datenarrays werden als String Literale behandelt. Beachte
                <link linkend="zend.db.adapter.write.insert">diesen Abschnitt</link> für
                Informationen zur Nutzung von <acronym>SQL</acronym> Expressions in dem Datenarray.
            </para>

            <para>
                Das dritte Argument ist ein String der aus einer <acronym>SQL</acronym> Expression
                besteht, die genutzt wird um Kriterien für die Auswahl der zu ändernden Zeilen zu
                bestimmen. Die Werte und Bezeichner in diesem Argument werden nicht escaped oder
                quotiert. An dieser Stelle muss darauf geachtet werden das sichergestellt ist, das
                dynamischer Inhalt sicher in diesen String eingefügt wird. In
                <link linkend="zend.db.adapter.quoting">diesem Abschnitt</link> sind Methoden
                beschrieben die dabei helfen können.
            </para>

            <para>
                Der Rückgabewert ist die Anzahl der Betroffenen Zeilen der UPDATE Operation.
            </para>

            <example id="zend.db.adapter.write.update.example">
                <title>Aktualisieren von Zeilen</title>

                <programlisting language="php"><![CDATA[
$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$n = $db->update('bugs', $data, 'bug_id = 2');
]]></programlisting>
            </example>

            <para>
                Wenn das dritte Argument ausgelassen wird, werden alle Zeilen der Tabelle mit den
                Werten des Datenarrays aktualisiert.
            </para>

            <para>
                Wenn ein Array mit Strings als drittes Argument übergeben wird, werden diese
                Strings als eine Expression von Ausdrücken, getrennt von <constant>AND</constant>
                Operatoren, zusammengefügt.
            </para>

            <para>
                Wenn man ein Array von Arrays als drittes Argument anbietet, werden die Werte
                automatisch in die Schlüssel eingefügt. Diese werden dann zusammen zu Ausdrücken
                verbunden, getrennt von <constant>AND</constant> Operatoren.
            </para>

            <example id="zend.db.adapter.write.update.example-array">
                <title>Aktualisieren von Zeilen unter Nutzung eines Arrays von Expressions</title>

                <programlisting language="php"><![CDATA[
$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$where[] = "reported_by = 'goofy'";
$where[] = "bug_status = 'OPEN'";

$n = $db->update('bugs', $data, $where);

// Der erstellte SQL Syntax ist:
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
]]></programlisting>
            </example>

            <example id="zend.db.adapter.write.update.example-arrayofarrays">
                <title>Zeilen aktualisieren durch Verwendung von einem Array von Arrays</title>

                <programlisting language="php"><![CDATA[
$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$where['reported_by = ?'] = 'goofy';
$where['bug_status = ?']  = 'OPEN';

$n = $db->update('bugs', $data, $where);

// Das resultierende SQL ist:
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.write.delete">
            <title>Löschen von Daten</title>

            <para>
                Daten können aus einer Datenbanktabelle mit der <methodname>delete()</methodname>
                Methode gelöscht werden. Diese Methode benötigt zwei Argumente: Das erste ist ein
                String der die Tabelle benennt.
            </para>

            <para>
                Das zweite Argument ist ein String der aus einer <acronym>SQL</acronym> Expression
                besteht, welche Kriterien für die zu löschenden Zeilen enthält. Die Werte und
                Bezeichner in diesem Argument werden nicht escaped quotiert. An dieser Stelle muss
                darauf geachtet werden das sichergestellt ist, das dynamischer Inhalt sicher in
                diesen String eingefügt wird. In <link linkend="zend.db.adapter.quoting">diesem
                    Abschnitt</link> sind Methoden beschrieben die dabei helfen können.
            </para>

            <para>
                Der Rückgabewert ist die Anzahl der Betroffenen Zeilen der DELETE Operation.
            </para>

            <example id="zend.db.adapter.write.delete.example">
                <title>Löschen von Zeilen</title>
                <programlisting language="php"><![CDATA[
$n = $db->delete('bugs', 'bug_id = 3');
]]></programlisting>
            </example>

            <para>
                Wenn das zweite Argument ausgelassen wird, werden alle Zeilen der Tabelle gelöscht.
            </para>

            <para>
                Wenn ein Array mit Strings als zweites Argument übergeben wird, werden diese
                Strings als eine Expression von Ausdrücken, getrennt von <constant>AND</constant>
                Operatoren, zusammengefügt.
            </para>

            <para>
                Wenn man ein Array von Arrays als zweites Argument übergibt, werden die Werte
                automatisch in die Schlüssel eingefügt. Diese werden dann zusammen zu Ausdrücken
                verbunden, getrennt durch <constant>AND</constant> Operatoren.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.db.adapter.quoting">
        <title>Quotierung von Werten und Bezeichnern</title>

        <para>
            Beim Erzeugen von <acronym>SQL</acronym> Anfragen ist es häufig nötig
            <acronym>PHP</acronym> Variablen in die <acronym>SQL</acronym> Expression einzufügen.
            Dies ist riskant, weil der Wert eines <acronym>PHP</acronym> Strings bestimmte Zeichen
            enthalten kann, wie das Anführungszeichen, was zu ungültiger <acronym>SQL</acronym>
            Syntax führen kann. Zum Beispiel, zu beachten ist die ungerade Anzahl der
            Anführungszeichen in der folgenden Anfrage:
        </para>

        <programlisting language="php"><![CDATA[
$name = "O'Reilly";
$sql = "SELECT * FROM bugs WHERE reported_by = '$name'";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O'Reilly'
]]></programlisting>

        <para>
            Noch schlimmer ist das Risiko, dass solche Code-Fehler von einer Person absichtlich
            ausgenutzt werden um die Funktion der Webanwendung zu manipulieren. Wenn der Wert einer
            <acronym>PHP</acronym> Variablen über die Nutzung von <acronym>HTTP</acronym> Parametern
            oder eines anderen Mechanismus gesetzt werden kann, könnte eine Person die
            <acronym>SQL</acronym> Anfragen nutzen um Dinge zu tun, wozu sie nicht gedacht sind, wie
            Daten ausgeben, wozu die Person keine Zugangsberechtigung hat. Dies ist eine ernst zu
            nehmende und weit verbreitete Technik um die Sicherheit einer Anwendung zu verletzen,
            bekannt unter dem Namen "SQL Injection" (siehe <ulink
                url="http://en.wikipedia.org/wiki/SQL_Injection">http://en.wikipedia.org/wiki/SQL_Injection</ulink>).
        </para>

        <para>
            Die <classname>Zend_Db</classname> Adapterklassen bieten bequeme Methoden, die helfen
            die Verletzbarkeit durch <acronym>SQL</acronym> Injection Angriffe im
            <acronym>PHP</acronym> Code zu reduzieren. Die Lösung ist bestimmte Zeichen, wie
            Anführungszeichen, in <acronym>PHP</acronym> Werten zu ersetzen bevor sie in
            <acronym>SQL</acronym> Strings eingefügt werden. Dies schützt sowohl vor versehentlicher
            als auch vor absichtlicher Manipulation von <acronym>SQL</acronym> Strings durch
            <acronym>PHP</acronym> Variablen, die spezielle Zeichen enthalten.
        </para>

        <sect3 id="zend.db.adapter.quoting.quote">
            <title>Nutzung von quote()</title>

            <para>
                Die <methodname>quote()</methodname> Methode benötigt ein Argument, einen skalaren
                String Wert. Sie gibt den Wert mit ersetzten speziellen Zeichen, passend zu dem
                eingesetzten <acronym>RDBMS</acronym>, und umgeben von Stringwertbegrenzern zurück.
                Der Standard <acronym>SQL</acronym> Stringwertbegrenzer ist das einfache
                Anführungszeichen (').
            </para>

            <example id="zend.db.adapter.quoting.quote.example">
                <title>Nutzung von quote()</title>

                <programlisting language="php"><![CDATA[
$name = $db->quote("O'Reilly");
echo $name;
// 'O\'Reilly'

$sql = "SELECT * FROM bugs WHERE reported_by = $name";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
]]></programlisting>
            </example>

            <para>
                Zu beachten ist, dass der Rückgabewert von <methodname>quote()</methodname> die
                Stringwertbegrenzer enthält. Dies ist ein Unterschied zu anderen Methoden die
                spezielle Zeichen ersetzen, aber keine Stringwertbegrenzer hinzufügen, wie z.B.
                <ulink
                    url="http://www.php.net/mysqli_real_escape_string">mysql_real_escape_string()</ulink>.
            </para>

            <para>
                Es kann notwendig sein Werte in Anführungszeichen zu setzen oder nicht je nach dem
                Kontext des <acronym>SQL</acronym> Datentyps in dem diese verwendet werden. Zum
                Beispiel darf, in einigen <acronym>RDBMS</acronym> Typen, ein Integer Wert nicht wie
                in String in Anführungszeichen gesetzt werden, wenn dieser mit einer Integer-Typ
                Spalte oder einem Ausdruck verglichen wird. Anders gesagt ist das folgende in
                einigen <acronym>SQL</acronym> Implementationen ein Fehler, wenn angenommen wird
                dass <property>intColumn</property> einen <acronym>SQL</acronym> Datentyp von
                <constant>INTEGER</constant> besitzt
            </para>

            <programlisting language="php"><![CDATA[
SELECT * FROM atable WHERE intColumn = '123'
]]></programlisting>

            <para>
                Es kann das optionale zweite Argument der <methodname>quote()</methodname> Methode
                verwendet werden um die Verwendung von Anführungszeichen selektiv für den
                spezifizierten <acronym>SQL</acronym> Datentyp auszuwählen.
            </para>

            <example id="zend.db.adapter.quoting.quote.example-2">
                <title>Verwenden von quote() mit einem SQL Typ</title>

                <programlisting language="php"><![CDATA[
$value = '1234';
$sql = 'SELECT * FROM atable WHERE intColumn = '
     . $db->quote($value, 'INTEGER');
]]></programlisting>
            </example>

            <para>
                Jede <classname>Zend_Db_Adapter</classname> Klasse hat den Namen des nummerischen
                <acronym>SQL</acronym> Datentyps für die respektive Marke von
                <acronym>RDBMS</acronym> codiert. Man kann genauso die Konstanten
                <constant>Zend_Db::INT_TYPE</constant>,
                <constant>Zend_Db::BIGINT_TYPE</constant>, und
                <constant>Zend_Db::FLOAT_TYPE</constant> verwenden um Code in einem mehr
                <acronym>RDBMS</acronym>-unabhängigen Weg zu schreiben.
            </para>

            <para>
                <classname>Zend_Db_Table</classname> definiert <acronym>SQL</acronym> Typen zu
                <methodname>quote()</methodname> automatisch wenn <acronym>SQL</acronym> Abfragen
                erstellt werden die einer Tabellen Schlüssel Spalte entsprechen.
            </para>
        </sect3>

        <sect3 id="zend.db.adapter.quoting.quote-into">
            <title>Nutzung von quoteInto()</title>

            <para>
                Die typischste Anwendung von Quotierung ist das Einfügen von <acronym>PHP</acronym>
                Variablen in eine <acronym>SQL</acronym> Expression oder Anweisung. Die
                <methodname>quoteInto()</methodname> Methode kann verwendet werden um dies in einem
                Schritt zu erledigen. Die Methode benötigt zwei Argumente: Das erste Argument ist
                ein String der ein Platzhaltersymbol (?) enthält, und das zweite
                Argument ist ein Wert oder eine <acronym>PHP</acronym> Variable die den Platzhalter
                ersetzen soll.
            </para>

            <para>
                Das Platzhaltersymbol ist das gleiche Symbol wie es von vielen
                <acronym>RDBMS</acronym> Marken für Lage betreffende Parameter verwendet wird, aber
                die <methodname>quoteInto()</methodname> Methode bildet nur Abfrageparameter nach.
                Die Methode fügt den Wert in den String ein, ersetzt dabei spezielle
                Zeichen und fügt Stringwertbegrenzer ein. Echte Abfrageparameter sorgen für eine
                Trennung von <acronym>SQL</acronym> String und Parametern wenn die Anweisung vom
                <acronym>RDBMS</acronym> Server verarbeitet wird.
            </para>

            <example id="zend.db.adapter.quoting.quote-into.example">
                <title>Nutzung von quoteInto()</title>

                <programlisting language="php"><![CDATA[
$sql = $db->quoteInto("SELECT * FROM bugs WHERE reported_by = ?", "O'Reilly");

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
]]></programlisting>
            </example>

            <para>
                Man kann den optionalen dritten Parameter von <methodname>quoteInto()</methodname>
                verwenden um den <acronym>SQL</acronym> Datentyp zu spezifizieren. Nummerische
                Datentypen werden nicht in Anführungszeichen gesetzt und andere Typen werden in
                Anführungszeichen gesetzt.
            </para>

            <example id="zend.db.adapter.quoting.quote-into.example-2">
                <title>Verwenden von quoteInto() mit einem SQL Typ</title>

                <programlisting language="php"><![CDATA[
$sql = $db
    ->quoteInto("SELECT * FROM bugs WHERE bug_id = ?", '1234', 'INTEGER');

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 1234
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.quoting.quote-identifier">
            <title>Nutzung von quoteIdentifier()</title>

            <para>
                Werte könnten nicht der einzige Teil der <acronym>SQL</acronym> Syntax sein, der
                Variabel sein soll. Wenn <acronym>PHP</acronym> Variablen genutzt werden um
                Tabellen, Spalten oder andere Bezeichner in den <acronym>SQL</acronym> Anweisungen
                zu benennen, könnte es nötig sein das diese Strings ebenfalls quotiert werden
                müssen. Standardmäßig haben <acronym>SQL</acronym> Bezeichner Syntaxregeln wie
                <acronym>PHP</acronym> und die meißten anderen Programmiersprachen. Zum Beispiel
                dürfen Bezeichner keine Leerzeichen, bestimmte Punktierung, spezielle Zeichen oder
                Internationale Zeichen enthalten. Außerdem sind bestimmte Wörter für die
                <acronym>SQL</acronym> Syntax reserviert und dürfen nicht als Bezeichner verwendet
                werden.
            </para>

            <para>
                Dennoch hat <acronym>SQL</acronym> ein Feature mit Namen
                <emphasis>delimited identifiers (begrenzte Bezeichner)</emphasis>, welches eine
                größere Auswahl bei der Schreibweise von Bezeichnern erlaubt. Wenn ein
                <acronym>SQL</acronym> Bezeichner mit dem richtigen Typ von´ Quotierung
                eingeschlossen ist, können Schreibweisen für die Bezeichner verwendet werden, die
                ohne der Quotierung ungültig wären. Begrenzte Bezeichner können Leerzeichen,
                Punktierung oder internationale Zeichen enthalten. Desweiteren dürfen auch von der
                <acronym>SQL</acronym> Syntax reservierte Wörter verwendet werden, wenn sie von
                Bezeichner Begrenzungszeichen eingeschlossen sind.
            </para>

            <para>
                Die <methodname>quoteIdentifier()</methodname> Methode funktioniert wie
                <methodname>quote()</methodname>, aber sie wendet die Bezeichner Begrenzungszeichen
                entsprechend dem verwendeten Adapter an. Zum Beispiel nutzt Standard
                <acronym>SQL</acronym> doppelte Anführungszeichen (") zum begrenzen von
                Bezeichnern und die meisten der <acronym>RDBMS</acronym> Marken nutzen ebenfalls
                dieses Symbol. MySQL hingegen benutzt back-quotes (`) als
                Standardzeichen. Die <methodname>quoteIdentifier()</methodname> Methode ersetzt
                außerdem spezielle Zeichen im String Argument.
            </para>

            <example id="zend.db.adapter.quoting.quote-identifier.example">
                <title>Nutzung von quoteIdentifier()</title>

                <programlisting language="php"><![CDATA[
// Wir könnten einen Tabellennamen haben, der ein in SQL reserviertes Wort ist
$tableName = $db->quoteIdentifier("order");

$sql = "SELECT * FROM $tableName";

echo $sql
// SELECT * FROM "order"
]]></programlisting>
            </example>

            <para>
                <acronym>SQL</acronym> begrenzte Bezeichner beachten die Groß- und Kleinschreibung,
                im Gegensatz zu nicht quotierten Bezeichnern. Daher muss, bei Verwendung von
                begrenztern Bezeichnern, die Schreibung der Bezeichner genau der Schreibung der
                Bezeichner im Tabellenschema entsprechen. Einschließlich der Groß- und
                Kleinschreibung.
            </para>

            <para>
                In den meisten Fällen wo <acronym>SQL</acronym> innerhalb der
                <classname>Zend_Db</classname> Klassen generiert wird, werden standardmäßig alle
                Bezeichner automatisch begrenzt. Dieses Verhalten kann mit der Option
                <constant>Zend_Db::AUTO_QUOTE_IDENTIFIERS</constant> geändert werden. Dies muss
                beim Instanziieren des Adapters wie in <link
                    linkend="zend.db.adapter.connecting.parameters.example2">diesem Beispiel</link>
                angegeben werden.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.db.adapter.transactions">
        <title>Kontrollieren von Datenbank Transaktionen</title>

        <para>
            Datenbanken definieren Transaktionen als logische Einheiten von Arbeit, die als einzelne
            Änderung übergeben oder rückgängig gemacht werden kann, selbst wenn sie auf
            verschiedenen Tabellen operiert. Alle Anfragen an einen Datenbank werden im Kontext
            einer Transaktion ausgeführt, selbst wenn der Datenbanktreiber sie implizit Verwaltet.
            Es wird <emphasis>auto-commit</emphasis> Modus genannt, wenn der Datenbanktreiber eine
            Transaktion für jede Anweisung erzeugt, und diese direkt nach dem Ausführen des
            <acronym>SQL</acronym> Statements übergibt. Standardmäßig operieren alle
            <classname>Zend_Db</classname> Adapterklassen im auto-commit Modus.
        </para>

        <para>
            Alternativ kann der Begin und das Ergebnis einer Transaktion selbst spezifiziert
            werden, und damit kann kontrolliert werden wieviele <acronym>SQL</acronym> Anfragen in
            einer Gruppe enthalten sind, die entweder übergeben oder rückgängig gemacht wird, als
            eine einzelne Operation. Um eine Transaktion zu initiieren wird die
            <methodname>beginTransaction()</methodname> Methode verwendet. Anschließend folgende
            <acronym>SQL</acronym> Anweisungen werden im Kontext der selben Transaktion ausgeführt
            bis sie explizit aufgelöst wird.
        </para>

        <para>
            Um eine Transaktion aufzulösen wird entweder die <methodname>commit()</methodname> oder
            die <methodname>rollBack()</methodname> Methode verwendet. Die
            <methodname>commit()</methodname> Methode markiert die Änderungen die während der
            Transaktionen durchgeführt wurden als übergeben, was bedeutet das die Effekte dieser
            Änderungen in anderen Transaktionen angezeigt werden.
        </para>

        <para>
            Die <methodname>rollBack()</methodname> Methode tut das Gegenteil: sie verwirft die
            Änderungen die während der Transaktionen durchgeführt wurden. Die Änderungen werden
            gewissermaßen ungeschehen gemacht, der Status der Daten ändert sich zurück auf jenen
            wie sie vor Beginn der Transaktion waren. Allerdings hat das rückgängig machen keinen
            Einfluss auf Änderungen die von anderen, gleichzeitig laufenden Transaktionen
            verursacht wurden.
        </para>

        <para>
            Nach dem Auflösen der Transaktion befindet sich der
            <classname>Zend_Db_Adapter</classname> wieder im auto-commit Modus, bis
            <methodname>beginTransaction()</methodname> wieder aufgerufen wird.
        </para>

        <example id="zend.db.adapter.transactions.example">
            <title>Verwalten einer Transaktion um Konsistenz sicher zu stellen</title>

            <programlisting language="php"><![CDATA[
// Eine Transaktion explizit starten
$db->beginTransaction();

try {
    // Versuchen einen oder mehrere Abfragen auszuführen
    $db->query(...);
    $db->query(...);
    $db->query(...);

    // Wenn alle erfolgreich waren, übertrage die Transaktion
    // und alle Änderungen werden auf einmal übermittelt
    $db->commit();

} catch (Exception $e) {
    // Wenn irgendeine der Abfragen fehlgeschlagen ist, wirf eine Ausnahme, wir
    // wollen die komplette Transaktion zurücknehmen, alle durch die
    // Transaktion gemachten Änderungen wieder entfernen, auch die erfolgreichen
    // So werden alle Änderungen auf einmal übermittelt oder keine
    $db->rollBack();
    echo $e->getMessage();
}
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.db.adapter.list-describe">
        <title>Auflistung und Beschreibung von Tabellen</title>

        <para>
            Die <methodname>listTables()</methodname> Methode gibt ein Array von Strings zurück,
            mit den Namen aller Tabellen in der aktuellen Datenbank.
        </para>

        <para>
            Die <methodname>describeTable()</methodname> Methode gibt ein assoziatives Array von
            MetaDaten über die Tabelle zurück. Das erste Argument dieser Methode ist ein String der
            den Namen der Tabelle enthält. Das zweite Argument ist optional und benennt das Schema
            in dem die Tabelle besteht.
        </para>

        <para>
            Die Schlüssel des assoziativen Arrays sind die Spaltennamen der Tabelle. Der zugehörige
            Wert jeder Spalte ist ebenfalls ein assoziatives Array mit den folgenden Schlüsseln und
            Werten:
        </para>

        <table frame="all" cellpadding="5" id="zend.db.adapter.list-describe.metadata">
            <title>Metadata Felder die von describeTable() zurückgegeben werden</title>

            <tgroup cols="3" align="left" colsep="1" rowsep="1">
                <thead>
                    <row>
                        <entry>Schlüssel</entry>
                        <entry>Typ</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry><constant>SCHEMA_NAME</constant></entry>
                        <entry>(string)</entry>
                        <entry>Name des Datenbankschemas in welchem diese Tabelle existiert.</entry>
                    </row>

                    <row>
                        <entry><constant>TABLE_NAME</constant></entry>
                        <entry>(string)</entry>
                        <entry>Name der Tabelle zu welcher diese Spalte gehört.</entry>
                    </row>

                    <row>
                        <entry><constant>COLUMN_NAME</constant></entry>
                        <entry>(string)</entry>
                        <entry>Name der Spalte.</entry>
                    </row>

                    <row>
                        <entry><constant>COLUMN_POSITION</constant></entry>
                        <entry>(integer)</entry>
                        <entry>Ordinale Position der Spalte in der Tabelle.</entry>
                    </row>

                    <row>
                        <entry><constant>DATA_TYPE</constant></entry>
                        <entry>(string)</entry>
                        <entry><acronym>RDBMS</acronym> Name des Datentyps der Spalte.</entry>
                    </row>

                    <row>
                        <entry><constant>DEFAULT</constant></entry>
                        <entry>(string)</entry>
                        <entry>Standardwert der Spalte, wenn angegeben.</entry>
                    </row>

                    <row>
                        <entry><constant>NULLABLE</constant></entry>
                        <entry>(boolean)</entry>

                        <entry>
                            <constant>TRUE</constant> wenn die Spalte <acronym>SQL</acronym>
                            <constant>NULL</constant> akzeptiert, <constant>FALSE</constant> wenn
                            die Spalte eine <constant>NOT</constant> <constant>NULL</constant>
                            Bedingung hat.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>LENGTH</constant></entry>
                        <entry>(integer)</entry>

                        <entry>
                            Länge oder Größe der Spalte wie vom <acronym>RDBMS</acronym> angegeben.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>SCALE</constant></entry>
                        <entry>(integer)</entry>

                        <entry>
                            Scalar vom Typ <acronym>SQL</acronym> <constant>NUMERIC</constant> oder
                            <constant>DECIMAL</constant>.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>PRECISION</constant></entry>
                        <entry>(integer)</entry>

                        <entry>
                            Präzision des Typs <acronym>SQL</acronym> <constant>NUMERIC</constant>
                            oder <constant>DECIMAL</constant>.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>UNSIGNED</constant></entry>
                        <entry>(boolean)</entry>

                        <entry>
                            <constant>TRUE</constant> wenn ein Integer-basierender Typ als
                            <constant>UNSIGNED</constant> angegeben wird.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>PRIMARY</constant></entry>
                        <entry>(boolean)</entry>

                        <entry>
                            <constant>TRUE</constant> wenn die Spalte Teil des Primärschlüsssels der
                            Tabelle ist.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>PRIMARY_POSITION</constant></entry>
                        <entry>(integer)</entry>

                        <entry>
                            Ordinale Position (1-basierend) der Spalte des Primärschlüssels.
                        </entry>
                    </row>

                    <row>
                        <entry><constant>IDENTITY</constant></entry>
                        <entry>(boolean)</entry>

                        <entry>
                            <constant>TRUE</constant> wenn die Spalte einen auto-increment Wert
                            nutzt.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <note>
            <title>Wie das IDENTITY Metadata Feld zu speziellen RDBMS zuzuordnen ist</title>

            <para>
                Das <constant>IDENTITY</constant> Metadata Feld wurd gewählt als ein 'idiomatischer'
                Ausdruck um eine Relation von Ersatzschlüsseln zu repräsentieren. Dieses Feld ist
                üblicherweise durch die folgenden Werte bekannt:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <constant>IDENTITY</constant> - <acronym>DB2</acronym>,
                        <acronym>MSSQL</acronym>
                    </para>
                </listitem>

                <listitem><para><constant>AUTO_INCREMENT</constant> - MySQL</para></listitem>
                <listitem><para><constant>SERIAL</constant> - PostgreSQL</para></listitem>

                <listitem>
                    <para><constant>SEQUENCE</constant> - Oracle</para></listitem>
                </itemizedlist>
        </note>

        <para>
            Wenn keine Tabelle mit dem Tabellennamen und dem optional angegebenen Schemanamen
            existiert, gibt <methodname>describeTable()</methodname> ein leeres Array zurück.
        </para>
    </sect2>

    <sect2 id="zend.db.adapter.closing">
        <title>Schließen einer Verbindung</title>

        <para>
            Normalerweise ist es nicht nötig eine Datenbankverbindung zu schließen.
            <acronym>PHP</acronym> räumt automatisch alle Ressourcen am Ende einer Anfrage auf und
            die Datenbankerweiterungen sind so designed das sie Verbindungen beenden wenn Referenzen
            zu ihren Objekten aufgeräumt werden.
        </para>

        <para>
            Trotzdem könnte es sinnvoll sein, wenn ein lang andauerndes <acronym>PHP</acronym>
            Script verwendet wird, das viele Datenbankverbindungen hat, diese zu schließen um zu
            vermeiden das die Kapazität des <acronym>RDBMS</acronym> Servers überschritten wird. Die
            <methodname>closeConnection()</methodname> Methode der Adapterklasse kann verwendet
            werden um die zugrundeliegende Datenbankverbindung explizit zu schließen.
        </para>

        <para>
            Seit Release 1.7.2, kann man prüfen ob man mit der
            <methodname>isConnected()</methodname> prüfen ob man aktuell mit dem
            <acronym>RDBMS</acronym> Server verbunden ist. Das bedeutet das eine Verbindungs
            Ressource initialisiert und nicht geschlossen wurde. Diese Funktion ist aktuell nicht in
            der Lage zu prüfen ob zum Beispiel die Server Seite die Verbindung geschlossen hat. Das
            wird intern verwendet um die Verbindung zu schließen. Das erlaubt es die Verbindung ohne
            Fehler mehrere Male zu schließen. Das war bereits vor 1.7.2 der Fall für
            <acronym>PDO</acronym> Adapter, aber nicht für die anderen.
        </para>

        <example id="zend.db.adapter.closing.example">
            <title>Schließen einer Datenbankverbindung</title>

            <programlisting language="php"><![CDATA[
$db->closeConnection();
]]></programlisting>
        </example>

        <note>
            <title>Unterstützt Zend_Db persistente Verbindungen?</title>

            <para>
                Ja, Persistenz wird durch das Hinzufügen des <property>persistent</property> Flags
                in der Konfiguration (nicht driver_configuration) und dessen Setzen auf
                <constant>TRUE</constant> bei einem Adapter in <classname>Zend_Db</classname>
                unterstützt.
            </para>

            <example id="zend.db.adapter.connecting.persistence.example">
                <title>Verwendung des Persistence Flags mit dem Oracle Adapter</title>

                <programlisting language="php"><![CDATA[
$db = Zend_Db::factory('Oracle', array(
    'host'       => '127.0.0.1',
    'username'   => 'webuser',
    'password'   => 'xxxxxxxx',
    'dbname'     => 'test',
    'persistent' => true
));
]]></programlisting>
            </example>

            <para>
                Es ist zu beachten das die Verwendung von persistenten Verbindungen einen Exzess
                an Idle Verbindungen auf dem <acronym>RDBMS</acronym> Server verursachen kann, was
                mehr Probleme macht als jeder Performance Gewinn den man durch die Verminderung des
                Overheads eines Verbindungsaufbaues erhalten kann.
            </para>

            <para>
                Datenbankverbindungen haben einen Status. Natürlich existieren einige Objekte auf
                dem <acronym>RDBMS</acronym> Server im Gültigkeitsbereich einer Session. Beispiele
                dafür sind locks, user variablen, temporary tables und Informationen über die
                zuletzt ausgeführte Anfrage, sowie betroffene Zeilen und zuletzt generierte ID
                Werte. Wenn persistente Verbindungen genutzt werden könnte die Anwendung Zugriff auf
                ungültige oder privilegierte Daten erlangen, die in einem vorigen
                <acronym>PHP</acronym> Request erzeugt wurden.
            </para>

            <para>
                Aktuell unterstützen nur die Oracle, <acronym>DB2</acronym> und
                <acronym>PDO</acronym> Adapter (wo es von <acronym>PHP</acronym> spezifiziert ist)
                Persistenz in <classname>Zend_Db</classname>.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.db.adapter.other-statements">
        <title>Ausführen anderer Datenbank Anweisungen</title>

        <para>
            Es könnte Fälle geben in denen direkter Zugriff auf das Verbindungsobjekt benötigt wird,
            wie es von der <acronym>PHP</acronym> Erweiterung bereitgestellt wird. Einige der
            Erweiterungen könnten Features anbieten, welche nicht von Methoden der
            <classname>Zend_Db_Adapter_Abstract</classname> Klasse auftauchen..
        </para>

        <para>
            Zum Beispiel werden alle <acronym>SQL</acronym> Anweisungen von
            <classname>Zend_Db</classname> vorbereitet und dann ausgeführt. Trotzdem gibt es einige
            Features welche nicht kompatibel mit vorbereiteten Anweisungen sind.
            <constant>DDL</constant> Anweisungen wie <constant>CREATE</constant> und
            <constant>ALTER</constant> können in MySQL nicht vorbereitet werden. Auch können
            <acronym>SQL</acronym> Anweisungen keinen Nutzen aus dem <ulink
                url="http://dev.mysql.com/doc/refman/5.1/en/query-cache-how.html">MySQL Query
                Cache</ulink> ziehen, bei einer geringeren MySQL Version als 5.1.17.
        </para>

        <para>
            Die meisten <acronym>PHP</acronym> Datenbankerweiterungen bieten eine Methode um
            <acronym>SQL</acronym> Anweisung auszuführen ohne diese vorzubereiten. Zum Beispiel
            bietet <acronym>PDO</acronym> die Methode <methodname>exec()</methodname>. Das
            Verbindungsobjekt der <acronym>PHP</acronym> Erweiterung kann kann mit der Methode
            <methodname>getConnection()</methodname> direkt verwendet werden.
        </para>

        <example id="zend.db.adapter.other-statements.example">
            <title>Ausführen eines nicht-prepared Statements mit einem PDO Adapter</title>

            <programlisting language="php"><![CDATA[
$result = $db->getConnection()->exec('DROP TABLE bugs');
]]></programlisting>
        </example>

        <para>
            So ähnlich können auch andere Methoden oder Eigenschaften der speziellen
            <acronym>PHP</acronym> Datenbankerweiterung genutzt werden. Zu beachten dabei ist
            jedoch, dass dadurch möglicherweise die Anwendung auf das angegebene Interface,
            bereitgestellt von einer Erweiterung für ein bestimmtes <acronym>RDBMS</acronym>,
            beschränkt wird.
        </para>

        <para>
            In zukünftigen Versionen von <classname>Zend_Db</classname> werden Möglichkeiten gegeben
            sein, um Methoden Startpunkte hinzuzufügen, für Funktionalitäten die den unterstützten
            <acronym>PHP</acronym> Datenbankerweiterungen gemein sind. Dies wird die
            Rückwärtskompatibilität nicht beeinträchtigen.
        </para>
    </sect2>

    <sect2 id="zend.db.adapter.server-version">
        <title>Erhalten der Server Version</title>

        <para>
            Seit Release 1.7.2 kann man die Version des Servers in einem <acronym>PHP</acronym>
            artigen Stil erhalten damit man es mit <methodname>version_compare()</methodname>
            verwenden kann. Wenn die Information nicht vorhanden ist erhält man
            <constant>NULL</constant> zurück.
        </para>

        <example id="zend.db.adapter.server-version.example">
            <title>Prüfen der Server Version bevor eine Abfrage gestartet wird</title>

            <programlisting language="php"><![CDATA[
$version = $db->getServerVersion();
if (!is_null($version)) {
    if (version_compare($version, '5.0.0', '>=')) {
        // mach was
    } else {
        // mach was anderes
    }
} else {
    // Server Version ist unmöglich zu lesen
}
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.db.adapter.adapter-notes">
        <title>Anmerkungen zu bestimmten Adaptern</title>

        <para>
            Dieser Abschnitt beschreibt Unterschiede zwischen den verschieden Adapterklassen auf die
            man achtgeben sollte.
        </para>

        <sect3 id="zend.db.adapter.adapter-notes.sqlsrv">
            <title>Microsoft SQL Server</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen 'Sqlsrv' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterung sqlsrv.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Es wird nur Microsoft <acronym>SQL</acronym> Server 2005 oder höher
                        unterstützt.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Microsoft <acronym>SQL</acronym> Server unterstützt keine Sequenzen, daher
                        ignoriert <methodname>lastInsertId()</methodname> das Primary Key Argument
                        und gibt immer den letzten Wert zurück der für den auto-increment Schlüssel
                        generiert wurde wenn ein Tabellenname spezifiziert wurde oder die letzte
                        Insert Abfrage eine Id zurückgegeben hat. Die
                        <methodname>lastSequenceId()</methodname> Methode gibt
                        <constant>NULL</constant> zurück.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <classname>Zend_Db_Adapter_Sqlsrv</classname> setzt
                        <constant>QUOTED_IDENTIFIER</constant> ON unmittelbar nach der
                        Verbindung zu einer <acronym>SQL</acronym> Server Datenbank. Dadurch
                        verwendet der Treiber das standardmäßige <acronym>SQL</acronym> Trennzeichen
                        (<emphasis>"</emphasis>) statt den propietären eckigen Klammern die der
                        <acronym>SQL</acronym> Server für die Identifikatoren als Trennzeichen
                        verwendet.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Man kann <property>driver_options</property> als Schlüssel im Options Array
                        spezifizieren. Der Wert kann alles hieraus sein: <ulink
                            url="http://msdn.microsoft.com/en-us/library/cc296161(SQL.90).aspx">http://msdn.microsoft.com/en-us/library/cc296161(SQL.90).aspx</ulink>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Man kann <methodname>setTransactionIsolationLevel()</methodname> verwenden
                        um einen Isolations Level für die aktuelle Verbindung zu setzen. Der Wert
                        kann wie folgt sein: <constant>SQLSRV_TXN_READ_UNCOMMITTED</constant>,
                        <constant>SQLSRV_TXN_READ_COMMITTED</constant>,
                        <constant>SQLSRV_TXN_REPEATABLE_READ</constant>,
                        <constant>SQLSRV_TXN_SNAPSHOT</constant> oder
                        <constant>SQLSRV_TXN_SERIALIZABLE</constant>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Mit <acronym>ZF</acronym> 1.9 ist das mindestens unterstützte Build der
                        <acronym>PHP</acronym> <acronym>SQL</acronym> Server erweiterung von
                        Microsoft 1.0.1924.0 und die Version des <acronym>MSSQL</acronym> Server
                        Native Clients 9.00.3042.00.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.ibm-db2">
            <title>IBM DB2</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen 'Db2' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterung
                        <constant>IBM_DB2</constant>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <acronym>IBM</acronym> <acronym>DB2</acronym> unterstützt sowohl Sequenzen
                        als auch auto-increment Schlüssel. Daher sind die Argumente für
                        <methodname>lastInsertId()</methodname> optional. Werden keine Argumente
                        angegeben, gibt der Adapter den letzten Wert der für den auto-increment Key
                        generiert wurde zurück. Werden Argumente angegeben, gibt der Adapter den
                        letzten Wert der für die Sequenz mit dem Namen, entsprechend der Konvention,
                        '<emphasis>table</emphasis>_<emphasis>column</emphasis>_seq' generiert
                        wurde zurück.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.mysqli">
            <title>MySQLi</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen 'Mysqli' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterung mysqli.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        MySQL unterstützt keine Sequenzen, daher ignoriert
                        <methodname>lastInsertId()</methodname> Argumente und gibt immer den
                        letzten Wert der für den auto-increment Schlüssel generiert wurde zurück.
                        Die <methodname>lastSequenceId()</methodname> Methode gibt
                        <constant>NULL</constant> zurück.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.oracle">
            <title>Oracle</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen 'Oracle' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterung oci8.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Oracle unterstützt keine auto-increment Schlüssel, daher sollte der Name
                        einer Sequenz an <methodname>lastInsertId()</methodname> oder
                        <methodname>lastSequenceId()</methodname> übergeben werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Die Oracle Erweiterung unterstützt keine positionierten Parameter. Es müssen
                        benannte Parameter verwendet werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Aktuell wird die <constant>Zend_Db::CASE_FOLDING</constant> Option vom
                        Oracle Adapter nicht unterstützt. Um diese Option mit Oracle zu nutzen muss
                        der <acronym>PDO</acronym> <acronym>OCI</acronym> Adapter verwendet werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Standardmäßig werden <acronym>LOB</acronym> Felder als
                        <acronym>OCI</acronym>-Log Objekte zurückgegeben. Man kann Sie für alle
                        Anfragen als String empfangen indem die Treiberoption
                        '<property>lob_as_string</property>' verwendet wird, oder für spezielle
                        Anfragen durch Verwendung von
                        <methodname>setLobAsString(boolean)</methodname> auf dem Adapter oder dem
                        Statement.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-ibm">
            <title>PDO Adapter für IBM DB2 und für Informix Dynamic Server (IDS)</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen '<classname>Pdo_Ibm</classname>' spezifiziert.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterungen
                        <acronym>PDO</acronym> und <acronym>PDO_IBM</acronym>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Es muß mindestens die <acronym>PDO_IBM</acronym> Erweiterung mit der Version
                        1.2.2 verwendet werden. Wenn eine ältere Version verwendet wird, muß die
                        <acronym>PDO_IBM</acronym> Erweiterung über <acronym>PECL</acronym>
                        hochgerüstet werden.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-mssql">
            <title>PDO Microsoft SQL Server</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen '<classname>Pdo_Mssql</classname>' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterungen pdo und
                        pdo_dblib.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Microsoft <acronym>SQL</acronym> Server unterstützt keine Sequenzen, daher
                        ignoriert <methodname>lastInsertId()</methodname> Argumente und gibt immer
                        den letzten Wert der für den auto-increment Schlüssel generiert wurde
                        zurück. Die <methodname>lastSequenceId()</methodname> Methode gibt
                        <constant>NULL</constant> zurück.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Wenn man mit Unicode Strings in einer anderen Codierung als
                        <acronym>UCS</acronym>-2 (wie <acronym>UTF</acronym>-8) arbeitet, kann es
                        sein das man eine Konvertierung im eigenen Anwendungscode durchführen, oder
                        die Daten in einer Binären Spalte speichern muß. Referieren Sie bitte auf
                        <ulink url="http://support.microsoft.com/kb/232580">Microsoft's Knowledge
                            Base</ulink> für weitere Informationen.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <classname>Zend_Db_Adapter_Pdo_Mssql</classname> setzt
                        <constant>QUOTED_IDENTIFIER</constant> ON direkt nach dem Verbinden zu
                        einer <acronym>SQL</acronym> Server Datenbank. Dadurch verwendet der Treiber
                        das Standard <acronym>SQL</acronym> Bezeichner Begrenzungssymbol
                        (") an Stelle der proprietären Eckige-Klammer Syntax die der
                        <acronym>SQL</acronym> Server standradmäßig nutzt.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Es kann <property>pdoType</property> als ein Schlüssel im Optionsarray
                        gesetzt werden. Der Wert kann "mssql" (der Standard), "dblib", "freetds",
                        oder "sybase" sein. Diese Option beeinflusst den <acronym>DNS</acronym>
                        Prefix, welchen der Adapter beim Konstruieren des <acronym>DNS</acronym>
                        Strings benutzt. Sowohl "freetds" als auch "sybase" implementieren einen
                        Prefix von "sybase:", welcher für den <ulink
                            url="http://www.freetds.org/">FreeTDS</ulink> Satz von Libraries
                        verwendet wird. Siehe auch <ulink
                            url="http://www.php.net/manual/de/ref.pdo-dblib.connection.php">http://www.php.net/manual/de/ref.pdo-dblib.connection.php</ulink>
                        für weitere Informationen über die <acronym>DNS</acronym> Prefixe die von
                        diesem Treiber verwendet werden.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-mysql">
            <title>PDO MySQL</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen '<classname>Pdo_Mysql</classname>' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterungen pdo und
                        pdo_mysql.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        MySQL unterstützt keine Sequenzen, daher ignoriert
                        <methodname>lastInsertId()</methodname> Argumente und gibt immer den
                        letzten Wert der für den auto-increment Schlüssel generiert wurde zurück.
                        Die <methodname>lastSequenceId()</methodname> Methode gibt
                        <constant>NULL</constant> zurück.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-oci">
            <title>PDO Oracle</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen '<classname>Pdo_Oci</classname>' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterungen pdo und
                        pdo_oci.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Oracle unterstützt keine auto-increment Schlüssel, daher sollte der Name
                        einer Sequenz an <methodname>lastInsertId()</methodname> oder
                        <methodname>lastSequenceId()</methodname> übergeben werden.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-pgsql">
            <title>PDO PostgreSQL</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen '<classname>Pdo_Pgsql</classname>' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterungen pdo und
                        pdo_pgsql.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        PostgreSQL unterstützt sowohl Sequenzen als auch auto-increment Schlüssel.
                        Daher sind die Argumente für <methodname>lastInsertId()</methodname>
                        optional. Werden keine Argumente angegeben, gibt der Adapter den letzten
                        Wert der für den auto-increment Key generiert wurde zurück. Werden
                        Argumente angegeben, gibt der Adapter den letzten Wert der für die Sequenz
                        mit dem Namen, entsprechend der Konvention,
                        '<emphasis>table</emphasis>_<emphasis>column</emphasis>_seq' generiert
                        wurde zurück.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-sqlite">
            <title>PDO SQLite</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter wird in der <methodname>factory()</methodname> Methode mit
                        dem Namen '<classname>Pdo_Sqlite</classname>' angegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Dieser Adapter nutzt die <acronym>PHP</acronym> Erweiterungen pdo und
                        pdo_sqlite.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        SQLite unterstützt keine Sequenzen, daher ignoriert
                        <methodname>lastInsertId()</methodname> Argumente und gibt immer den
                        letzten Wert der für den auto-increment Schlüssel generiert wurde zurück.
                        Die <methodname>lastSequenceId()</methodname> Methode gibt
                        <constant>NULL</constant> zurück.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Um mit einer SQLite2 Datenbank zu Verbinden muss
                        <command>'sqlite2' => true</command> in dem Array von Parametern beim
                        Erzeugen einer Instanz des <classname>Pdo_Sqlite</classname> Adapters
                        angegeben werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Um mit einer in-memory SQLite Datenbank zu verbinden muss
                        <command>'dbname' => ':memory:'</command> in dem Array von Parametern beim
                        Erzeugen einer Instanz des <classname>Pdo_Sqlite</classname> Adapters
                        angegeben werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Ältere Versionen des SQLite Treibers in <acronym>PHP</acronym> scheinen die
                        <acronym>PRAGMA</acronym> Kommandos nicht zu unterstützen, die benötigt
                        werden um sicherzustellen, dass kurze Spaltennamen in Ergebnissätzen
                        verwendet werden. Wenn in den Ergebnissätzen Schlüssel der Art
                        "tabellenname.spaltenname" bei Nutzung von JOIN Abfragen auftreten, sollte
                        die aktuellste <acronym>PHP</acronym> Version installiert werden.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.firebird">
            <title>Firebird (Interbase)</title>

            <itemizedlist>
                <listitem>
                    <para>
                        Dieser Adapter verwendet die <acronym>PHP</acronym> Erweiterung
                        php_interbase.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Firebird (Interbase) unterstützt keine auto-increment Schlüssel, deswegen
                        sollte der Name einer Sequenz bei <methodname>lastInsertId()</methodname>
                        oder <methodname>lastSequenceId()</methodname> spezifiziert werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Aktuell wird die <constant>Zend_Db::CASE_FOLDING</constant> Option vom
                        Firebird (Interbase) Adapter nicht unterstützt. Nicht gequotete Identifizierer
                        werden automatisch in Großschreibweise zurückgegeben.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Der Name des Adapters ist <classname>ZendX_Db_Adapter_Firebird</classname>.
                    </para>
                    <para>
                        Beachte das der Parameter adapterNamespace mit dem Wert
                        <classname>ZendX_Db_Adapter</classname> zu verwenden ist.
                    </para>
                    <para>
                        Wir empfehlen die <filename>gds32.dll</filename> (oder Ihr Linux Äquivalent)
                        welche mit <acronym>PHP</acronym> ausgeliefert wird, auf die gleiche Version
                        wie am Server hochzurüsten. Für Firebird ist das Äquivalent zu
                        <filename>gds32.dll</filename> die <filename>fbclient.dll</filename>.
                    </para>
                    <para>
                        Standardmäßig werden alle Identifikatoren (Tabellennamen, Felder) in
                        Großschreibweise zurückgegeben.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>
    </sect2>
</sect1>

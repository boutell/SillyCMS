<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 22140 -->
<!-- Reviewed: no -->
<sect1 id="zend.cache.frontends">
    <title>Zend_Cache Frontends</title>

    <sect2 id="zend.cache.frontends.core">
        <title>Zend_Cache_Core</title>

        <sect3 id="zend.cache.frontends.core.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Core</classname> ist ein spezielles Frontend, da es der Kern
                dieses Moduls ist. Es ist ein generelles Cache Frontend und wurde von anderen
                Klassen erweitert.
            </para>

            <note>
                <para>
                    Alle Frontends sind von <classname>Zend_Cache_Core</classname> abgeleitet, so
                    dass deren Methoden und Optionen (wie folgt beschrieben) auch in anderen
                    Frontends vorhanden sind. Deswegen werden sie dort nicht dokumentiert.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.cache.frontends.core.options">
            <title>Mögliche Optionen</title>

            <para>
                Diese Optionen werden der Factory Methode übergeben wie im nachfolgenden Beispiel
                demonstriert.
            </para>

            <table id="zend.cache.frontends.core.options.table">
                <title>Core Frontend Optionen</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><emphasis>caching</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>

                            <entry>
                                Ein- / Ausschalten vom Caching (kann sehr nützlich für das
                                Debuggen von gecachten Skripten sein)
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>cache_id_prefix</emphasis></entry>
                            <entry><type>String</type></entry>
                            <entry><constant>NULL</constant></entry>

                            <entry>
                                Ein Präfix für alle Cache IDs. Wenn er auf
                                <constant>NULL</constant> gesetzt wird, wird kein Cache ID Präfix
                                verwendet. Der Cache ID Präfix erstellt grundsätzlich einen
                                Namespace im Cache, der verschiedenen Anwendungen oder Websites
                                die Verwendung eines gemeinsamen Caches erlaubt. Jede Anwendung
                                oder Website kann einen anderen Cache ID Prüfix verwenden sodas
                                spezielle Cache IDs mehr als einmal verwendet werden können.
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>lifetime</emphasis></entry>
                            <entry><type>Integer</type></entry>
                            <entry>3600</entry>

                            <entry>
                                Cache Lebensdauer (in Sekunden), wenn auf
                                <constant>NULL</constant> gesetzt, ist der Cache für immer gültig.
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>logging</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>

                            <entry>
                                Wenn auf <constant>TRUE</constant> gesetzt, wird das Logging durch
                                <classname>Zend_Log</classname> aktiviert (aber das System wird
                                langsamer)
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>write_control</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>

                            <entry>
                                Ein- / Ausschalten der Schreibkontrolle (der Cache wird gleich
                                gelesen, nachdem er geschrieben wurde, um fehlerhafte Einträge zu
                                finden); das Einschalten der Schreibkontrolle wird das Schreiben
                                des Caches etwas verlangsamen, aber nicht das Lesen des Caches (es
                                können defekte Cache Dateien entdeckt werden, aber es ist keine
                                perfekte Kontrolle)
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>automatic_serialization</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>

                            <entry>
                                Ein- / Ausschalten der automatischen Serialisierung, kann dafür
                                benutzt werden, um Daten direkt zu speichern, welche keine Strings
                                sind (aber es ist langsamer)
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>automatic_cleaning_factor</emphasis></entry>
                            <entry><type>Integer</type></entry>
                            <entry>10</entry>

                            <entry>
                                Ausschalten / Abgleichen des automatischen Löschprozesses (Garbage
                                Collector): 0 heißt keine automatische Löschung des Caches, 1
                                heißt Systematische Cache Löschung und x &gt; 1 heißt
                                automatisches zufälliges Löschen 1 mal nach x Schreiboperationen.
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>ignore_user_abort</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>

                            <entry>
                                Auf <constant>TRUE</constant> gesetzt, wird der Kern das
                                <acronym>PHP</acronym> Flag ignore_user_abort innerhalb der
                                <methodname>save()</methodname> Methode setzen um Cache Korruption
                                in einigen Fällen zu verhindern
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Beispiele</title>

            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben.
            </para>

            <para>
                Wenn nur Strings in den Cache gespeichert werden (denn mit der
                "automatic_serialization" Option wäre es möglich Booleans zu speichern), kann ein
                kompakterer Weg wie folgt gewählt werden:
            </para>

            <programlisting language="php"><![CDATA[
// Es wird angenommen das $cache existiert

$id = 'myBigLoop'; // Die Cache ID von dem "das gecached werden soll"

if (!($data = $cache->load($id))) {
    // Cache miss

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// [...] Irgendwas mit $data machen (ausgeben, verarbeiten, usw.)
]]></programlisting>

            <para>
                Wenn mehrere Blöcke von Daten oder Daten Instanzen gecached werden sollen, ist die
                Idee dahinter die gleiche:
            </para>

            <programlisting language="php"><![CDATA[
// Sicherstellen, dass eindeutige Identifizierer verwendet werden:
$id1 = 'foo';
$id2 = 'bar';

// Block 1
if (!($data = $cache->load($id1))) {
    // Cache miss

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// Hier wird NIE gecached
echo('NIE GECACHED! ');

// Block 2
if (!($data = $cache->load($id2))) {
    // Cache miss

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);
]]></programlisting>

            <para>
                Wenn spezielle Werte gecached werden sollen (boolean mit der
                "automatic_serialization" Option) oder leere Strings kann die kompakte Erstellung
                wie oben gezeigt nicht verwendet werden. Der Cache Eintrag muß formell getestet
                werden.
            </para>

            <programlisting language="php"><![CDATA[
// Die kompakte Erstellung
// (nicht gut wenn leere Strings und/oder boolsche Werte gecached werden)
if (!($data = $cache->load($id))) {

    // Cache fehlgeschlagen

    // [...] wir erstellen $data

    $cache->save($data);

}

// wir machen etwas mit $data

// [...]

// die komplette Erstellung (funktioniert in jedem Fall)
if (!($cache->test($id))) {

    // Cache fehlgeschlagen

    // [...] wir erstellen $data

    $cache->save($data);

} else {

    // Cache getroffen

    $data = $cache->load($id);

}

// Wir machen irgendetwas mit $data
]]></programlisting>
       </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.output">
        <title>Zend_Cache_Frontend_Output</title>

        <sect3 id="zend.cache.frontends.output.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Frontend_Output</classname> ist ein Ausgabe-Empfangendes
                Frontend. Es verwendet den Ausgabe Puffer in <acronym>PHP</acronym>, um alles
                zwischen der <methodname>start()</methodname> und der
                <methodname>end()</methodname> Methode zu fangen.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.options">
            <title>Mögliche Optionen</title>

            <para>
                Dieses Frontend hat keine bestimmten Optionen zusätzlich zu denen von
                <classname>Zend_Cache_Core</classname>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.examples">
            <title>Beispiele</title>

            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben. Hier ist es mit kleinen
                Änderungen:
            </para>

            <programlisting language="php"><![CDATA[
// Wenn es ein Cache Miss ist, wird das puffern der Ausgabe ausgelöst
if( ! ($cache->start('mypage'))) {

    // Alle wie gewohnt ausgeben
    echo 'Hallo Welt! ';
    echo 'Das wird gecached ('.time().') ';

    $cache->end(); // Ausgabepufferung beenden

}

echo 'Hier wird nie gecached ('.time().').';
]]></programlisting>

            <para>
                Die Verwendung dieser Form ist ziemlich einfach, um Ausgabe caching in einem bereits
                bestehenden Projekt, mit nur wenig oder gar keinen Codeänderungen, zu erhalten.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.function">
        <title>Zend_Cache_Frontend_Function</title>

        <sect3 id="zend.cache.frontends.function.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Frontend_Function</classname> cached das Ergebnis von
                Funktionsaufrufen. Es hat eine einzelne Hauptmethode genannt
                <methodname>call()</methodname>, welche den Funktionsnamen und Parameter für den
                Aufruf in einem Array entgegennimmt.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.function.options">
            <title>Mögliche Optionen</title>

            <table id="zend.cache.frontends.function.options.table">
                <title>Cache Frontend Optionen</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><emphasis>cache_by_default</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>

                            <entry>
                                Wenn <constant>TRUE</constant>, wird der Funktionsaufruf
                                standardmäßig gecached
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>cached_functions</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry></entry>
                            <entry>Funktionsnamen, die immer gecached werden sollen</entry>
                        </row>

                        <row>
                            <entry><emphasis>non_cached_functions</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry></entry>
                            <entry>Funktionsnamen, die nie gecached werden sollen</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.function.examples">
            <title>Beispiele</title>

            <para>
                Die Verwendung der <methodname>call()</methodname> Funktion ist die gleiche, wie
                die von <methodname>call_user_func_array()</methodname> in <acronym>PHP</acronym>:
            </para>

            <programlisting language="php"><![CDATA[
$cache->call('veryExpensiveFunc', $params);

// $params ist ein Array
// Für das Aufrufen von veryExpensiveFunc(1, 'foo', 'bar') mit Caching kann,
// z.B. $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar')) benutzt
// werden
]]></programlisting>

            <para>
                <classname>Zend_Cache_Frontend_Function</classname> ist elegant genug, um beides zu
                cachen, den Rückgabewert der Funktion und deren interne Ausgabe.
            </para>

            <note>
                <para>
                    Man kann jede eingebaute oder benutzerdefinierte Funktion übergeben, mit
                    Ausnahme von <methodname>array()</methodname>, <methodname>echo()</methodname>,
                    <methodname>empty()</methodname>, <methodname>eval()</methodname>,
                    <methodname>exit()</methodname>, <methodname>isset()</methodname>,
                    <methodname>list()</methodname>, <methodname>print()</methodname> und
                    <methodname>unset()</methodname>.
                </para>
            </note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.class">
        <title>Zend_Cache_Frontend_Class</title>

        <sect3 id="zend.cache.frontends.class.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Frontend_Class</classname> ist unterschiedlich zu
                <classname>Zend_Cache_Frontend_Function</classname>, weil es das Cachen von Objekten
                und statischen Methodenaufrufen erlaubt.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.class.options">
            <title>Mögliche Optionen</title>

            <table id="zend.cache.frontends.class.options.table">
                <title>Class Frontend Optionen</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Datentyp</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><emphasis>cached_entity</emphasis> (Notwendig)</entry>
                            <entry><type>Mixed</type></entry>
                            <entry></entry>

                            <entry>
                                  Wenn auf einen Klassennamen gesetzt, wird eine abstrakte Klasse
                                  gecached und es werden statische Aufrufe verwendet; wenn auf ein
                                  Objekt gesetzt, wird deren Objektmethoden gecached
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>cache_by_default</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>

                            <entry>
                                  Wenn <constant>TRUE</constant>, wird der Aufruf standardmäßig
                                  gecached
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>cached_methods</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry></entry>
                            <entry>Methodennamen, die immer gecached werden sollen</entry>
                        </row>

                        <row>
                            <entry><emphasis>non_cached_methods</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry></entry>
                            <entry>Methodennamen, die nie gecached werden sollen</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.class.examples">
            <title>Beispiele</title>

            <para>
                zum Beispiel, um einen statischen Aufruf zu cachen:
            </para>

            <programlisting language="php"><![CDATA[
class Test {

    // Statische Methode
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => 'Test' // Der Name der Klasse
);
// [...]

// Der gecachte Aufruf
$result = $cache->foobar('1', '2');
]]></programlisting>

            <para>
                Um klassische Methodenaufrufe zu cachen :
            </para>

            <programlisting language="php"><![CDATA[
class Test {

    private $_string = 'Hallo !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => new Test() // Eine Instanz der Klasse
);
// [...]

// Der gecachte Aufruf
$res = $cache->foobar2('1', '2');
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>

        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Frontend_File</classname> ist ein Frontend angetrieben durch
                den Änderungszeitpunkt einer "Masterdatei". Es ist wirklich interessant für
                Beispiele in Konfigurations- oder Templateanwendungen. Es ist auch möglich mehrere
                Masterdateien zu verwenden.
            </para>

            <para>
                Zum Beispiel eine <acronym>XML</acronym> Konfigurationsdatei, welche von einer
                Funktion geparsed wird und die ein "Config Objekt" zurückgibt (wie durch
                <classname>Zend_Config</classname>). Mit
                <classname>Zend_Cache_Frontend_File</classname> kann das "Config Objekt" im Cache
                gespeichert werden (um zu Verhindern, das die <acronym>XML</acronym> Konfiguration
                jedes mal geparsed wird), aber mit einer strengen Abhängigkeit zur "Masterdatei".
                Wenn also die <acronym>XML</acronym> Konfigurationsdatei geändert wird, wird der
                Cache sofort ungültig.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.file.options">
            <title>Mögliche Optionen</title>

            <table id="zend.cache.frontends.file.options.table">
                <title>File Frontend Optionen</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><emphasis>master_File (depreciated)</emphasis></entry>
                            <entry><type>String</type></entry>
                            <entry>''</entry>
                            <entry>Der komplette Pfad und Name der Master Datei</entry>
                        </row>

                        <row>
                            <entry><emphasis>master_files</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array()</methodname></entry>
                            <entry>Ein Array der kompletten Pfade der Masterdateien</entry>
                        </row>

                        <row>
                            <entry><emphasis>master_files_mode</emphasis></entry>
                            <entry><type>String</type></entry>
                            <entry><constant>Zend_Cache_Frontend_File::MODE_OR</constant></entry>

                            <entry>
                                <constant>Zend_Cache_Frontend_File::MODE_AND</constant> oder
                                <constant>Zend_Cache_Frontend_File::MODE_OR</constant> ;
                                bei <constant>MODE_AND</constant> müssen alle Masterdateien
                                angegriffen werden um einen Cache ungültig zu machen, bei
                                <constant>MODE_OR</constant> ist eine eizelne angegriffene Datei
                                genug um den Cache ungültig zu machen
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>ignore_missing_master_files</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>

                            <entry>
                                bei <constant>TRUE</constant> werden fehlende Masterdateien leise
                                ignoriert (andernfalls wird eine Exception geworfen)
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.file.examples">
            <title>Beispiele</title>

            <para>
                Die Verwendung dieses Frontends ist die gleiche wie die von
                <classname>Zend_Cache_Core</classname>. Es gibt kein eigenes Beispiel - was als
                einziges gemacht werden muß, ist das <emphasis>master_File</emphasis> zu
                definieren, wenn die Factory verwendet wird.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
        <title>Zend_Cache_Frontend_Page</title>

        <sect3 id="zend.cache.frontends.page.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Frontend_Page</classname> ist wie
                <classname>Zend_Cache_Frontend_Output</classname> aber entwickelt für eine komplette
                Seite. Es ist unmöglich <classname>Zend_Cache_Frontend_Page</classname> nur für das
                Cachen eines einzelnen Blockes zu verwenden.
            </para>

            <para>
                Andererseits wird die "Cache ID" automatisch berechnet mit
                <varname>$_SERVER['REQUEST_URI']</varname> und (abhängig von den Optionen) mit
                <varname>$_GET</varname>, <varname>$_POST</varname>, <varname>$_SESSION</varname>,
                <varname>$_COOKIE</varname>, <varname>$_FILES</varname>. Trotzdem muß nur eine
                Methode aufgerufen werden (<methodname>start()</methodname>), weil der Aufruf von
                <methodname>end()</methodname> immer vollautomatisch ist, wenn die Seite endet.
            </para>

            <para>
                Zur Zeit ist es nicht eingebaut, aber es ist ein <acronym>HTTP</acronym> abhängiges
                System geplant, um Bandbreiten zu sparen (das System wird ein
                "<acronym>HTTP</acronym> 304 nicht geändert" schicken, wenn der Cache gefunden
                wurde und wenn der Browser bereits eine gültige Version hat).
            </para>

            <note>
                <para>
                    Dieses Frontend arbeitet indem es eine Callback Funktion registriert welche
                    aufgerufen wird wenn das Buffern der Ausgabe welches es verwendet, gelöscht
                    wird. Damit dies korrekt arbeitet muss es der letzte Ausgabebuffer in der
                    Anfrage sein. Um dies zu garantieren <emphasis>muss</emphasis> der
                    Ausgabebuffer, den der Dispatcher verwendet, deaktiviert sein indem die
                    <methodname>setParam()</methodname> Methode von
                    <classname>Zend_Controller_Front</classname> verwendet wird. Zum Beispiel
                    <command>$front->setParam('disableOutputBuffering', true)</command> oder durch
                    Hinzufügen von "resources.frontcontroller.params.disableOutputBuffering = true"
                    zum eigenen Konfigurationsdatei der Bootstrap (<acronym>INI</acronym>
                    angenommen) wenn <classname>Zend_Application</classname> verwendet wird.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.cache.frontends.page.options">
            <title>Mögliche Optionen</title>

            <table id="zend.cache.frontends.page.options.table">
                <title>Page Frontend Optionen</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><emphasis>http_conditional</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>

                            <entry>
                                Verwendung des http_conditional Systems (zur Zeit nicht
                                implementiert)
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>debug_header</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>

                            <entry>
                                Wenn <constant>TRUE</constant>, wird ein Debugging Text vor
                                jeder gecacheten Seite hinzugefügt
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>default_options</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array(...siehe unten...)</methodname></entry>

                            <entry>
                                Ein assoziatives Array mit Standard Optionen:

                                <itemizedlist>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> per
                                                Default) cache</emphasis>: Cache ist aktiviert
                                            wenn <constant>TRUE</constant>
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> per
                                                Default) cache_with_get_variables</emphasis>: wenn
                                            <constant>TRUE</constant>, ist der Cache weiterhin
                                            aktiviert, selbst wenn es einige Variablen im
                                            <varname>$_GET</varname> Array gibt
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> per
                                                Default) cache_with_post_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, ist der Cache
                                            weiterhin aktiviert, selbst wenn es einige Variablen
                                            im <varname>$_POST</varname> Array gibt
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> per
                                                Default) cache_with_session_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, ist der Cache
                                            weiterhin aktiviert, selbst wenn es einige Variablen
                                            im <varname>$_SESSION</varname> Array gibt
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> per
                                                Default) cache_with_files_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, ist der Cache
                                            weiterhin aktiviert, selbst wenn es einige Variablen
                                            im <varname>$_FILES</varname> Array gibt
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> per
                                                Default) cache_with_cookie_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, ist der Cache
                                            weiterhin aktiviert, selbst wenn es einige Variablen
                                            im <varname>$_COOKIE</varname> Array gibt
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> per
                                                Default) make_id_with_get_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, wird die Cache ID vom
                                            Inhalt des <varname>$_GET</varname> Arrays abhängig
                                            sein
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> per
                                                Default) make_id_with_post_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, wird die Cache ID vom
                                            Inhalt des <varname>$_POST</varname> Arrays abhängig
                                            sein
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> per
                                                Default)
                                                make_id_with_session_variables</emphasis>: wenn
                                            <constant>TRUE</constant>, wird die Cache ID vom
                                            Inhalt des <varname>$_SESSION</varname> Arrays
                                            abhängig sein
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> per
                                                Default) make_id_with_files_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, wird die Cache ID vom
                                            Inhalt des <varname>$_FILES</varname> Arrays abhängig
                                            sein
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> per
                                                Default) make_id_with_cookie_variables</emphasis>:
                                            wenn <constant>TRUE</constant>, wird die Cache ID vom
                                            Inhalt des <varname>$_COOKIE</varname> Arrays
                                            abhängig sein
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(int, <constant>FALSE</constant> by default)
                                                specific_lifetime</emphasis>: wenn nicht
                                            <constant>FALSE</constant>, wird die angegebene
                                            Lifetime für das ausgewählte Regex verwendet
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(array, <methodname>array()</methodname> by
                                                default) tags</emphasis>: Tags für den Cache
                                            Eintrag
                                        </para>
                                    </listitem>

                                    <listitem>
                                        <para>
                                            <emphasis>(int, <constant>NULL</constant> by default)
                                                priority</emphasis>: Priorität (wenn das Backend
                                            das unterstützt)
                                        </para>
                                    </listitem>
                                </itemizedlist>
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>regexps</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array()</methodname></entry>

                            <entry>
                                Ein assoziatives Array, um Optionen nur für einige
                                <constant>REQUEST_URI</constant> zu setzen. Die Schlüssel sind
                                reguläre Ausdrücke (<acronym>PCRE</acronym>), die Werte sind
                                ein assoziatives Array mit spezifischen Optionen, die gesetzt
                                werden sollen, wenn der reguläre Ausdruck auf
                                <varname>$_SERVER['REQUEST_URI']</varname> passt (siehe die
                                default_options für eine Liste der verfügbaren Optionen); wenn
                                verschiedene reguläre Ausdrücke auf
                                <varname>$_SERVER['REQUEST_URI']</varname> passen, wird nur der
                                letzte verwendet.
                            </entry>
                        </row>

                        <row>
                            <entry><emphasis>memorize_headers</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array()</methodname></entry>

                            <entry>
                                Ein Array von Strings die zu einem <acronym>HTTP</acronym>
                                Headernamen korrespondieren. Aufgelistete Header werden mit den
                                Cache Daten gespeichert und wieder "abgespielt" wenn der Cache
                                getroffen wird.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.page.examples">
            <title>Beispiele</title>

            <para>
                Die Verwendung von <classname>Zend_Cache_Frontend_Page</classname> ist wirklich
                trivial :
            </para>

            <programlisting language="php"><![CDATA[
// [...] // Benötigt, Konfiguration und Factory

$cache->start();
// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt,
// und das Skript stoppt hier

// Rest der Seite ...
]]></programlisting>

            <para>
                Ein etwas komplexeres Beispiel, welches einen Weg zeigt, um ein zentralisiertes
                Cache Management in einer Bootstrap Datei zu erhalten (um es z.B. mit
                <classname>Zend_Controller</classname> zu verwenden)
            </para>

            <programlisting language="php"><![CDATA[
/*
 * Es sollte vermieden werden, zu viele Zeilen vor dem Cache Bereich zu setzen
 * zum Beispiel sollten für optimale Performanz "require_once" oder
 * "Zend_Loader::loadClass" nach dem Cache Bereich stehen
 */

$frontendOptions = array(
   'lifetime' => 7200,
   'debug_header' => true, // für das Debuggen
   'regexps' => array(
       // cache den gesamten IndexController
       '^/$' => array('cache' => true),

       // cache den gesamten IndexController
       '^/index/' => array('cache' => true),

       // wir cachen nicht den ArticleController...
       '^/article/' => array('cache' => false),

       // ...aber wir cachen die "View" Aktion von diesem ArticleController
       '^/article/view/' => array(
           'cache' => true,

           // und wir cachen sogar wenn es einige Variablen in $_POST gibt
           'cache_with_post_variables' => true,

           // aber die Cache Id wird vom $_POST Array abhängig sein
           'make_id_with_post_variables' => true,
       )
   )
);

$backendOptions = array(
    'cache_dir' => '/tmp/'
);

// erhalte ein Zend_Cache_Frontend_Page Objekt
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache->start();

// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt,
// und das Skript stoppt hier

// [...] das Ende der Bootstrap Datei
// diese Zeilen werden nicht ausgeführt, wenn der Cache ausgegeben wurde
]]></programlisting>
        </sect3>

        <sect3 id="zend.cache.frontends.page.cancel">
            <title>Die spezielle cancel Methode</title>

            <para>
                Aus Designgründen, kann es in einigen Fällen (zum Beispiel bei Verwendung von nicht
                <acronym>HTTP</acronym> 200 Return Codes), notwendig sein den aktuellen
                Cacheprozess zu unterbrechen. Deshalb zeigen wir für dieses spezielle Frontend die
                <methodname>cancel()</methodname> Methode.
            </para>

            <programlisting language="php"><![CDATA[
// [...] // Benötigt, Konfiguration und Factory

$cache->start();

// [...]

if ($someTest) {
    $cache->cancel();
    // [...]
}

// [...]
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.capture">
        <title>Zend_Cache_Frontend_Capture</title>

        <sect3 id="zend.cache.frontends.capture.introduction">
            <title>Einführung</title>

            <para>
                <classname>Zend_Cache_Frontend_Capture</classname> ist wie
                <classname>Zend_Cache_Frontend_Output</classname> aber für komplette Seiten
                gestaltet. Es ist nicht möglich <classname>Zend_Cache_Frontend_Capture</classname>
                für das Cachen eines einzelnen Blocks zu verwenden. Diese Klasse ist speziell dazu
                gestaltet um nur in Verbindung mit dem
                <classname>Zend_Cache_Backend_Static</classname> Backend zu funktionieren indem es
                komplette Seiten von <acronym>HTML</acronym> / <acronym>XML</acronym> oder anderen
                Inhalten in einer statischen physikalischen Datei auf dem lokalen Dateisystem
                cached.
            </para>

            <para>
                Sehen Sie bitte in die Dokumentation von
                <classname>Zend_Cache_Backend_Static</classname> für alle Use Cases bezüglich dieser
                Klasse.
            </para>

            <note>
                <para>
                    Dieses Frontend arbeitet indem es eine Callback Funktion registriert welche
                    aufgerufen wird wenn das Buffern der Ausgabe welches es verwendet, gelöscht
                    wird. Damit dies korrekt arbeitet muss es der letzte Ausgabebuffer in der
                    Anfrage sein. Um dies zu garantieren <acronym>muss</acronym> der Ausgabebuffer,
                    den der Dispatcher verwendet, deaktiviert sein indem die
                    <methodname>setParam()</methodname> Methode von
                    <classname>Zend_Controller_Front</classname> verwendet wird. Zum Beispiel
                    <command>$front->setParam('disableOutputBuffering', true)</command> oder durch
                    Hinzufügen von "resources.frontcontroller.params.disableOutputBuffering = true"
                    zum eigenen Konfigurationsdatei der Bootstrap (<acronym>INI</acronym>
                    angenommen) wenn <classname>Zend_Application</classname> verwendet wird.
                </para>
            </note>
        </sect3>
    </sect2>
</sect1>

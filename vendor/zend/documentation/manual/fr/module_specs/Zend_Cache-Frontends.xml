<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 22140 -->
<!-- Reviewed: no -->
<sect1 id="zend.cache.frontends">
    <title>Les frontends Zend_Cache</title>

    <sect2 id="zend.cache.frontends.core">
        <title>Zend_Cache_Core</title>

        <sect3 id="zend.cache.frontends.core.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Core</classname> est un frontend spécial parce qu'il est le
                coeur du module. C'est le frontend de cache générique qui est étendu par les autres
                classes.
            </para>

            <note>
                <para>
                    Tous les frontends héritent de <classname>Zend_Cache_Core</classname> ainsi ses
                    méthodes et options (décrites ci-dessous) seront aussi disponibles dans les
                    autres frontends, cependant ils ne sont pas documentés ici.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.cache.frontends.core.options">
            <title>Options disponibles</title>

            <para>
                Ces options sont passées à la méthode de fabrique comme montrées dans les
                exemples précédents.
            </para>

            <table id="zend.cache.frontends.core.options.table">
                <title>Options du frontend Core</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><emphasis>caching</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>
                            <entry>
                                Active / désactive le cache (peut-être très utile pour le
                                débogage de scripts en cache)
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>cache_id_prefix</emphasis></entry>
                            <entry><type>String</type></entry>
                            <entry><constant>NULL</constant></entry>
                            <entry>
                                Un préfixe pour tous les ID de cache, si réglé à
                                <constant>NULL</constant>, aucun préfixe d'ID de cache ne sera
                                utilisé. Le préfixe d'ID de cache sert essentiellement à créer des
                                espaces de noms dans le cache, permettant à plusieurs applications
                                ou sites Web d'utiliser un cache partagé. Chaque application ou
                                site web peut utilisé un préfixe d'ID de cache différent et un
                                préfixe peut aussi être utilisé plusieurs fois.
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>lifetime</emphasis></entry>
                            <entry><type>Integer</type></entry>
                            <entry>3600</entry>
                            <entry>
                                Temps de vie (en secondes) du cache, si défini à
                                <constant>NULL</constant>, le cache est valide indéfiniment
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>logging</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>
                            <entry>
                                Si défini à <constant>TRUE</constant>, le logging par
                                <classname>Zend_Log</classname> est activé (mais le système sera
                                plus lent)
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>write_control</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>
                            <entry>
                                Active / désactive le contrôle d'écriture (le cache est lu
                                juste après l'écriture pour détecter des entrées corrompues),
                                activer "writeControl" va ralentir un petit peu
                                l'écriture du cache, mais pas la lecture (il peut détecter des
                                fichiers de cache corrompus, mais ceci n'est pas un contrôle
                                parfait).
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>automatic_serialization</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>
                            <entry>
                                Active / désactive la sérialisation automatique, il peut
                                être utilisé pour enregistrer directement des données qui ne sont
                                pas des chaînes de caractères (mais c'est plus lent).
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>automatic_cleaning_factor</emphasis></entry>
                            <entry><type>Integer</type></entry>
                            <entry>0</entry>
                            <entry>
                                Active / désactive le nettoyage automatique ("garbage
                                collector"): 0 signifie aucun nettoyage automatique de cache, 1
                                signifie un nettoyage systématique du cache et x &gt; 1 signifie le
                                nettoyage aléatoire 1 fois toute les x écritures.
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>ignore_user_abort</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>
                            <entry>
                                Si réglé à <constant>TRUE</constant>, le cache active le drapeau
                                <acronym>PHP</acronym> "ignore_user_abort" dans la méthode
                                <methodname>save()</methodname> pour prévenir de la corruption du
                                cache dans certains cas.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Exemples</title>

            <para>Un exemple est donné dans le manuel, tout au début.</para>

            <para>
                Si vous stocker uniquement des chaînes de caractères dans le cache (parce
                qu'avec l'option "automatic_serialization", il est possible de stocker
                des booléens), vous pouvez utiliser une construction plus compact comme&#160;:
            </para>

            <programlisting language="php"><![CDATA[
// nous avons déjà $cache

$id = 'myBigLoop'; // id de cache de "ce que l'on veut cacher"

if (!($data = $cache->load($id))) {
    // cache absent

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// [...] fait quelque chose avec $data
// (affichage, passage ailleurs, etc, etc)
]]></programlisting>

            <para>
                Si vous voulez cacher des blocs multiples ou des instances de données, l'idée
                reste la même&#160;:
            </para>

            <programlisting language="php"><![CDATA[
// on s'assure que l'on utilise des identifiant uniques
$id1 = 'foo';
$id2 = 'bar';

// block 1
if (!($data = $cache->load($id1))) {
    // cache absent

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// ceci n'est pas affecté par la mise en cache
echo('NEVER CACHED! ');

// block 2
if (!($data = $cache->load($id2))) {
    // cache missed

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);
]]></programlisting>

            <para>
                Si vous voulez cacher des valeurs "spéciales" (des booléens avec l'option
                "automatic_serialization") ou des chaînes vides, vous ne pouvez pas
                utiliser la construction compacte montrée ci-dessus. Vous devez tester de manière
                formelle l'état du cache.
            </para>

            <programlisting language="php"><![CDATA[
// La construction compacte (ne pas utiliser si vous cachez
// des chaînes et/ou des booléens)
if (!($data = $cache->load($id))) {

    // cache absent

    // [...] on crée $data

    $cache->save($data);

}

// on fait qqch avec $data

// [...]

// La construction complète (fonctionne dans tous les cas)
if (!($cache->test($id))) {

    // cache absent

    // [...] on crée $data

    $cache->save($data);

} else {

    // lecture du cache

    $data = $cache->load($id);

}

// on fait qqch avec $data
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.output">
        <title>Zend_Cache_Frontend_Output</title>

        <sect3 id="zend.cache.frontends.output.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Frontend_Output</classname> est un frontend capturant la
                sortie. Il utilise la bufferisation de sortie de <acronym>PHP</acronym> pour
                capturer tout ce qui passe entre les méthodes <methodname>start()</methodname> et
                <methodname>end()</methodname>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.options">
            <title>Options disponibles</title>

            <para>
                Ce frontend n'a pas d'options spécifiques autres que celles de
                <classname>Zend_Cache_Core</classname>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.examples">
            <title>Exemples</title>

            <para>
                Un exemple est donnée dans le manuel, tout au début. Le voici avec des
                changements mineurs&#160;:
            </para>

            <programlisting language="php"><![CDATA[
// s'il y a un cache manquant, la bufferisation de sortie est lancée
if (!$cache->start('mypage')) {

    // affiche tout comme d'habitude
    echo 'Hello world! ';
    echo 'This is cached ('.time().') ';

    $cache->end(); // affiche ce qu'il y a dans le buffer
}

echo 'This is never cached ('.time().').';
]]></programlisting>

            <para>
                Utiliser cette forme est assez simple pour définir une mise de cache de
                sortie dans vos projets déjà en production, avec peu de refactorisation de
                code.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.function">
        <title>Zend_Cache_Frontend_Function</title>

        <sect3 id="zend.cache.frontends.function.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Frontend_Function</classname> met en cache les résultats des
                appels de fonction. Elle a une seule méthode principale appelée
                <methodname>call()</methodname> qui prend un nom de fonction et des paramètres pour
                l'appel dans un tableau.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.function.options">
            <title>Options disponibles</title>

            <table id="zend.cache.frontends.function.options.table">
                <title>Options du frontend Function</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><emphasis>cache_by_default</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>
                            <entry>
                                si <constant>TRUE</constant>, les appels de fonction seront mis en
                                cache par défaut
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>cached_functions</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry>''</entry>
                            <entry>les noms de fonctions seront toujours mis en cache</entry>
                        </row>
                        <row>
                            <entry><emphasis>non_cached_functions</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry>''</entry>
                            <entry>
                                les noms de fonctions ne doivent jamais être mis en
                                cache
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.function.examples">
            <title>Exemples</title>

            <para>
                Utiliser la fonction <methodname>call()</methodname> est la même chose qu'utiliser
                <methodname>call_user_func_array()</methodname> en <acronym>PHP</acronym>&#160;:
            </para>

            <programlisting language="php"><![CDATA[
$cache->call('veryExpensiveFunc', $params);

// $params est dans un tableau par exemple, pour appeler
// (avec mise en cache) : veryExpensiveFunc(1, 'foo', 'bar')
// vous devriez utiliser
$cache->call('veryExpensiveFunc', array(1, 'foo', 'bar'));
]]></programlisting>

            <para>
                <classname>Zend_Cache_Frontend_Function</classname> est assez intelligente pour
                mettre en cache la valeur de retour de la fonction, ainsi que sa sortie interne.
            </para>

            <note>
                <para>
                    Vous pouvez passer n'importe quelle fonction utilisateur à l'exception de
                    <methodname>array()</methodname>, <methodname>echo()</methodname>,
                    <methodname>empty()</methodname>, <methodname>eval()</methodname>,
                    <methodname>exit()</methodname>, <methodname>isset()</methodname>,
                    <methodname>list()</methodname>, <methodname>print()</methodname>
                    et <methodname>unset()</methodname>.
                </para>
            </note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.class">
        <title>Zend_Cache_Frontend_Class</title>

        <sect3 id="zend.cache.frontends.class.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Frontend_Class</classname> est différent de
                <classname>Zend_Cache_Frontend_Function</classname> parce qu'elle permet de mettre
                en cache les objets et les méthodes statiques.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.class.options">
            <title>Options disponibles</title>

            <table id="zend.cache.frontends.class.options.table">
                <title>Options du frontend Class</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><emphasis>cached_entity</emphasis> (requis)</entry>
                            <entry><type>Mixed</type></entry>
                            <entry></entry>
                            <entry>
                                si défini avec un nom de classe, nous allons mettre en cache
                                une classe abstraite et utiliser uniquement les appels
                                statiques&#160;; si défini avec un objet, nous allons mettre en
                                cache les méthodes de cet objet.
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>cache_by_default</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>TRUE</constant></entry>
                            <entry>
                                si <constant>TRUE</constant>, les appels vont être cachés par
                                défaut
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>cached_methods</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry></entry>
                            <entry>
                                les noms des méthodes qui seront toujours mis en
                                cache
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>non_cached_methods</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry></entry>
                            <entry>
                                les noms des méthodes qui ne doivent jamais être mises en
                                cache
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.class.examples">
            <title>Exemples</title>

            <para>Par exemple, pour mettre en cache des appels statiques&#160;:</para>

            <programlisting language="php"><![CDATA[
class test {

    // Méthode statique
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => 'test' // Le nom de la classe
);
// [...]

// l'appel caché
$res = $cache->foobar('1', '2');
]]></programlisting>

            <para>Pour mettre en cache des appels classiques aux méthodes&#160;:</para>

            <programlisting language="php"><![CDATA[
class test {

    private $_string = 'hello !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => new test() // Une instance de la classe
);
// [...]

// L'appel mis en cache
$res = $cache->foobar2('1', '2');
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>

        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Frontend_File</classname> est un frontend piloté par la
                modification d'un "fichier maître". C'est vraiment intéressant, par exemple, dans
                les problématiques de configuration ou de templates. Il est également possible
                d'utiliser plusieurs fichiers maîtres.
            </para>

            <para>
                Par exemple, vous avez un fichier de configuration <acronym>XML</acronym> qui est
                analysé par une fonction, celle-ci retourne un "objet de configuration" (comme avec
                <classname>Zend_Config</classname>). Avec
                <classname>Zend_Cache_Frontend_File</classname>, vous pouvez stocker l'objet de
                configuration dans le cache (pour éviter d'analyser le fichier de configuration
                <acronym>XML</acronym> chaque fois) mais avec une sorte de forte dépendance au
                fichier maître. Ainsi si le fichier <acronym>XML</acronym> de configuration est
                modifié, le cache est immédiatement invalide.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.file.options">
            <title>Options disponibles</title>

            <table id="zend.cache.frontends.file.options.table">
                <title>Options du frontend File</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><emphasis>master_file</emphasis> (déprécié)</entry>
                            <entry><type>String</type></entry>
                            <entry>''</entry>
                            <entry>le chemin complet et le nom du fichier maître</entry>
                        </row>
                        <row>
                            <entry><emphasis>master_files</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array()</methodname></entry>
                            <entry>un tableau de chemin complet de fichiers maîtres</entry>
                        </row>
                        <row>
                            <entry><emphasis>master_files_mode</emphasis></entry>
                            <entry><type>String</type></entry>
                            <entry><constant>Zend_Cache_Frontend_File::MODE_OR</constant></entry>
                            <entry>
                                <constant>Zend_Cache_Frontend_File::MODE_AND</constant> oU
                                <constant>Zend_Cache_Frontend_File::MODE_OR</constant> ; si
                                <constant>MODE_AND</constant>, alors tous les fichiers maîtres
                                doivent être modifiés pour rendre invalide le cache, si
                                <constant>MODE_OR</constant>, alors un seul fichier maître modifié
                                est nécessaire pour invalider le cache
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>ignore_missing_master_files</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>
                            <entry>
                                si <constant>TRUE</constant>, l'absence de fichiers maîtres est
                                ignoré silencieusement (sinon une exception est levée)
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.file.examples">
            <title>Exemples</title>

            <para>
                L'utilisation de ce frontend est la même que celle de
                <classname>Zend_Cache_Core</classname>. Il n'y a pas besoin d'exemple spécifique -
                la seule chose à faire est de définir le <emphasis>master_file</emphasis> lors de
                l'utilisation de la fabrique.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
        <title>Zend_Cache_Frontend_Page</title>

        <sect3 id="zend.cache.frontends.page.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Frontend_Page</classname> est comme
                <classname>Zend_Cache_Frontend_Output</classname> mais créé pour une page complète.
                Il est impossible d'utiliser <classname>Zend_Cache_Frontend_Page</classname> pour
                mettre en cache un bloc unique.
            </para>

            <para>
                D'un autre côté, le "cache ID", est calculé automatiquement avec
                <varname>$_SERVER['REQUEST_URI']</varname> et (en fonction des options)
                <varname>$_GET</varname>, <varname>$_POST</varname>, <varname>$_SESSION</varname>,
                <varname>$_COOKIE</varname>, <varname>$_FILES</varname>. De plus, vous avez
                seulement une méthode pour appeler (<methodname>start()</methodname>) parce que
                l'appel à <methodname>end()</methodname> est totalement automatique lorsque la page
                est terminé.
            </para>

            <para>
                Pour le moment, ceci n'est pas implémenté mais nous prévoyons d'ajouter un
                système de condition <acronym>HTTP</acronym> pour économiser de la bande passante
                (le système émettra un en-tête "<acronym>HTTP</acronym> 304 Not Modified" si le
                cache est trouvé, et si le navigateur a déjà la bonne version).
            </para>

            <note>
                <para>
                    Ce frontend opére en enregistrant une fonction de rappel qui doit être appelée
                    quand le buffer de sortie qu'il utilise est nettoyé. Dans le but de fonctionner
                    correctement, il doit être le buffer de sortie final de la requête. Pour
                    garantir ceci, le buffer de sortie utilisé par le distributeur (Dispatcher)
                    <emphasis>doit</emphasis> être désactivé en appelant la méthode
                    <methodname>setParam()</methodname> de
                    <classname>Zend_Controller_Front</classname>, par exemple
                    <command>$front->setParam('disableOutputBuffering', true);</command> ou en
                    ajoutant "resources.frontcontroller.params.disableOutputBuffering = true"
                    à votre fichier d'amorçage (présumé de type <acronym>INI</acronym>) si vous
                    utilisez <classname>Zend_Application</classname>.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.cache.frontends.page.options">
            <title>Options disponibles</title>

            <table id="zend.cache.frontends.page.options.table">
                <title>Options du frontend Page</title>

                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>Option</entry>
                            <entry>Type de données</entry>
                            <entry>Valeur par défaut</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><emphasis>http_conditional</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>
                            <entry>
                                utilisez le système "httpConditionnal" ou pas
                                (pas encore implémenté)
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>debug_header</emphasis></entry>
                            <entry><type>Boolean</type></entry>
                            <entry><constant>FALSE</constant></entry>
                            <entry>
                                si <constant>TRUE</constant>, un texte de débogage est ajouté avant
                                chaque page de cache
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>default_options</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array(...see below...)</methodname></entry>
                            <entry>
                                un tableau associatif d'options par défaut&#160;:
                                <itemizedlist>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> par
                                            défaut) cache</emphasis>&#160;:
                                            le cache est activé si <constant>TRUE</constant>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> par
                                            défaut) cache_with_get_variables</emphasis>&#160;: si
                                            <constant>TRUE</constant>, le cache est toujours activé
                                            même s'il y a des variables dans le tableau
                                            <varname>$_GET</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> par
                                            défaut) cache_with_post_variables</emphasis>&#160;: si
                                            <constant>TRUE</constant>, le cache est toujours activé
                                            même s'il y a des variables dans le tableau
                                            <varname>$_POST</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> par
                                            défaut) cache_with_session_variables</emphasis>&#160;:
                                            si <constant>TRUE</constant>, le cache est toujours
                                            activé s'il y a des variables dans le tableau
                                            <varname>$_SESSION</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> par
                                            défaut) cache_with_files_variables</emphasis>&#160;: si
                                            <constant>TRUE</constant>, le cache est toujours activé
                                            s'il y a des variables dans le tableau
                                            <varname>$_FILES</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>FALSE</constant> par
                                            défaut) cache_with_cookie_variables</emphasis>&#160;: si
                                            <constant>TRUE</constant>, le cache est toujours activé
                                            s'il y a des variables dans le tableau
                                            <varname>$_COOKIE</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> par
                                            défaut) make_id_with_get_variables</emphasis>&#160;: si
                                            <constant>TRUE</constant>, l'identifiant du cache sera
                                            dépendant du contenu du tableau <varname>$_GET</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> par
                                            défaut) make_id_with_post_variables</emphasis>&#160;:
                                            si <constant>TRUE</constant>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <varname>$_POST</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> par
                                            défaut) make_id_with_session_variables</emphasis>&#160;:
                                            si <constant>TRUE</constant>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <varname>$_SESSION</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> par
                                            défaut) make_id_with_files_variables</emphasis>&#160;:
                                            si <constant>TRUE</constant>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <varname>$_FILES</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(boolean, <constant>TRUE</constant> par
                                            défaut) make_id_with_cookie_variables</emphasis>&#160;:
                                            si <constant>TRUE</constant>, l'identifiant du cache
                                            sera dépendant du contenu du tableau
                                            <varname>$_COOKIE</varname>
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(int, <constant>FALSE</constant> par défaut)
                                            specific_lifetime</emphasis>&#160;: si
                                            <constant>TRUE</constant>, la durée de vie fournie sera
                                            utilisée pour l'expression régulière choisie
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(array, <methodname>array()</methodname> par
                                                défaut) tags</emphasis>&#160;:
                                            balises pour l'enregistrement en cache
                                        </para>
                                    </listitem>
                                    <listitem>
                                        <para>
                                            <emphasis>(int, <constant>NULL</constant> par défaut)
                                                priority</emphasis>&#160;:
                                            priorité (si le backend le supporte)
                                        </para>
                                    </listitem>
                            </itemizedlist></entry>
                        </row>
                        <row>
                            <entry><emphasis>regexps</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array()</methodname></entry>
                            <entry>
                                un tableau associatif pour définir les options, uniquement
                                pour certaines <constant>REQUEST_URI</constant>, les clés sont des
                                expressions régulières <acronym>PCRE</acronym>, les valeurs sont
                                des tableaux associatifs avec des options spécifiques pour définir
                                si les expressions régulières correspondent dans
                                <varname>$_SERVER['REQUEST_URI']</varname> (voir les options par
                                défaut pour la liste des options disponibles) ; si plusieurs
                                expressions régulières correspondent à un
                                <varname>$_SERVER['REQUEST_URI']</varname>, seule la dernière
                                sera utilisée.
                            </entry>
                        </row>
                        <row>
                            <entry><emphasis>memorize_headers</emphasis></entry>
                            <entry><type>Array</type></entry>
                            <entry><methodname>array()</methodname></entry>
                            <entry>
                                un tableau de chaînes correspondant aux noms d'en-têtes
                                <acronym>HTTP</acronym>. Les en-têtes listés seront stockées avec
                                les données de cache et renvoyées lorsque le cache sera rappelé.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </sect3>

        <sect3 id="zend.cache.frontends.page.examples">
            <title>Exemples</title>

            <para>
                L'utilisation de <classname>Zend_Cache_Frontend_Page</classname> est vraiment
                trivial&#160;:
            </para>

            <programlisting language="php"><![CDATA[
// [...] // require, configuration et factory

$cache->start();
// si le cache est trouvé, le résultat est envoyé au navigateur
// et le script s'arrête là

// reste de la page ...
]]></programlisting>

            <para>
                Un exemple plus complexe qui montre un moyen pour obtenir une gestion
                centralisée du cache dans un fichier d'amorçage (pour utiliser avec
                <classname>Zend_Controller</classname> par exemple)
            </para>

            <programlisting language="php"><![CDATA[
// vous devriez éviter de mettre trop de lignes avant la section
// de cache par exemple, pour des performances optimales,
// "require_once" ou "Zend_Loader::loadClass" devrait être
// après la section de cache

$frontendOptions = array(
   'lifetime' => 7200,
   'debug_header' => true, // pour le déboguage
   'regexps' => array(
       // met en cache la totalité d'IndexController
       '^/$' => array('cache' => true),

       // met en cache la totalité d'IndexController
       '^/index/' => array('cache' => true),

       // nous ne mettons pas en cache l'ArticleController...
       '^/article/' => array('cache' => false),

       // ...mais nous mettons en cache l'action "view"
       '^/article/view/' => array(
            // de cet ArticleController
           'cache' => true,

           // et nous mettons en cache même lorsqu'il y a
           // des variables dans $_POST
           'cache_with_post_variables' => true,

           // (mais le cache sera dépendent du tableau $_POST)
           'make_id_with_post_variables' => true,
       )
   )
);
$backendOptions = array(
    'cache_dir' => '/tmp/'
);

// obtenir un objet Zend_Cache_Frontend_Page
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache->start();
// si nous trouvons un cache, le résultat est envoyé au navigateur,
// et le script s'arrête là

// [...] la fin du fichier de démarrage
// (ces lignes ne seront pas exécutées si on trouve un cache)
]]></programlisting>
        </sect3>

        <sect3 id="zend.cache.frontends.page.cancel">
            <title>La méthode spécifique cancel()</title>

            <para>
                A cause de problèmes de design, dans certains cas (par exemple quand on
                utilise des codes de retour <acronym>HTTP</acronym> autres que 200), vous
                pouvez avoir besoin de stopper le processus de mise en cache courant. Il a donc été
                introduit pour ce frontend en particulier, la méthode
                <methodname>cancel()</methodname>.
            </para>

            <programlisting language="php"><![CDATA[
// [...] require, configuration et fabrique

$cache->start();

// [...]

if ($unTest) {
    $cache->cancel();
    // [...]
}

// [...]
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.capture">
        <title>Zend_Cache_Frontend_Capture</title>

        <sect3 id="zend.cache.frontends.capture.introduction">
            <title>Introduction</title>

            <para>
                <classname>Zend_Cache_Frontend_Capture</classname> is like
                <classname>Zend_Cache_Frontend_Output</classname> but designed for a complete page.
                It's impossible to use <classname>Zend_Cache_Frontend_Capture</classname> for
                caching only a single block. This class is specifically designed to operate in
                concert only with the <classname>Zend_Cache_Backend_Static</classname> backend to
                assist in caching entire pages of <acronym>HTML</acronym> / <acronym>XML</acronym>
                or other content to a physical static file on the local filesystem.
            </para>

            <para>
                Please refer to the documentation on
                <classname>Zend_Cache_Backend_Static</classname> for all use cases pertaining to
                this class.
            </para>

            <note>
                <para>
                    This frontend operates by registering a callback function to be called
                    when the output buffering it uses is cleaned. In order for this to operate
                    correctly, it must be the final output buffer in the request. To guarantee
                    this, the output buffering used by the Dispatcher <emphasis>must</emphasis> be
                    disabled by calling <classname>Zend_Controller_Front</classname>'s
                    <methodname>setParam()</methodname> method, for example,
                    <command>$front->setParam('disableOutputBuffering', true);</command> or adding
                    "resources.frontcontroller.params.disableOutputBuffering = true"
                    to your bootstrap configuration file (assumed <acronym>INI</acronym>) if using
                    <classname>Zend_Application</classname>.
                </para>
            </note>
        </sect3>
     </sect2>
</sect1>

<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 21815 -->
<!-- Reviewed: no -->
<sect1 id="zend.file.transfer.validators">
    <title>Validateurs pour Zend_File_Transfer</title>

    <para>
        <classname>Zend_File_Transfer</classname> est fourni avec de multiples validateurs
        liés qui doivent être utiliser pour accroître la sécurité et prévenir les attaques
        possibles. Notez que les validateurs ne sont bons que si vous les utilisez. Tous les
        validateurs qui sont fournis avec <classname>Zend_File_Transfer</classname> peuvent être
        trouvés avec le composant <classname>Zend_Validator</classname> et sont nommés
        <classname>Zend_Validate_File_*</classname>. Les validateurs suivants sont actuellement
        disponibles&#160;:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                <code>Count</code>&#160;: ce validateur vérifie le nombre de fichiers. Il est
                possible de définir un minimum et un maximum et une erreur sera lancée s'ils sont
                dépassés.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Crc32</code>&#160;: ce validateur vérifie la valeur de hachage crc32 du
                contenu d'un fichier. Il est basé sur le validateur <code>Hash</code> et en
                simplifiant son utilisation par le support unique du Crc32.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>ExcludeExtension</code>&#160;: ce validateur vérifie l'extension des
                fichiers. Il lancera une erreur quand un fichier aura une extension non souhaitée.
                Ainsi vous pouvez empêcher la validation de certaines extensions.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>ExcludeMimeType</code>&#160;: ce validateur vérifie le type <acronym>MIME</acronym> des
                fichiers. Il est aussi capable de valider un groupe de type <acronym>MIME</acronym> et générera une
                erreur quand le type <acronym>MIME</acronym> d'un fichier donné correspond.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Exists</code>&#160;: ce validateur vérifie l'existence des fichiers. Il
                lancera une erreur quand un fichier n'existera pas.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Extension</code>&#160;: ce validateur vérifie l'extension des fichiers. Il
                lancera une erreur quand un fichier n'aura pas l'extension définie.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>FilesSize</code>&#160;: ce validateur vérifie la taille complète de tous les
                fichiers à valider. Il conserve en mémoire la taille de tous les fichiers chargés et
                lance une erreur quand la somme de tous les fichiers dépasse la taille définie. Il
                est aussi possible de définir une taille minimum et maximum.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>ImageSize</code>&#160;: ce validateur vérifie la taille des images. Il valide
                la largeur et la hauteur et permet de paramétrer à la fois une valeur minimum et
                maximum.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>IsCompressed</code>&#160;: ce validateur vérifie si le fichier est compressé.
                Il est basé sur le validateur <code>MimeType</code> et valide les archives
                compressées comme zip ou arc. Vous pouvez aussi limiter à des types d'archives
                particuliers.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>IsImage</code>&#160;: ce validateur vérifie si un fichier est une image. Il
                est basé sur le validateur <code>MimeType</code> et valide les images comme jpg ou
                gif. Vous pouvez aussi limiter à des types d'images particuliers.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Hash</code>&#160;: ce validateur vérifie la valeur de hachage md5 du contenu
                d'un fichier. Il supporte de multiples algorithmes.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Md5</code>&#160;: ce validateur vérifie la valeur de hachage md5 du contenu
                d'un fichier. Il est basé sur le validateur <code>Hash</code> et en simplifiant son
                utilisation par le support unique du Md5.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>MimeType</code>&#160;: ce validateur vérifie le type <acronym>MIME</acronym> des fichiers. Il
                est aussi capable de valider des groupes de type <acronym>MIME</acronym> et de générer une erreur quand
                le type <acronym>MIME</acronym> d'un fichier donné ne correspond pas.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>NotExists</code>&#160;: ce validateur vérifie l'existence des fichiers. Il
                lancera une erreur quand un fichier existera déjà.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Sha1</code>&#160;: ce validateur vérifie la valeur de hachage sha1 du contenu
                d'un fichier. Il est basé sur le validateur <code>Hash</code> et en simplifiant son
                utilisation par le support unique du Sha1.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Size</code>&#160;: ce validateur permet de valider la taille d'un fichier en
                particulier. Il est possible de définir un minimum et un maximum et une erreur sera
                lancée s'ils sont dépassés.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>Upload</code>&#160;: ce validateur est interne, il vérifie si l'upload a
                produit une erreur. Vous ne devez pas le paramétrer, il est automatiquement activé
                par<code> Zend_File_Transfer</code> lui-même. Vous pouvez donc oublier ce
                validateur. Il faut juste savoir qu'il existe.
            </para>
        </listitem>

        <listitem>
            <para>
                <code>WordCount</code>&#160;: ce validateur est capable de vérifier le nombre de
                mots à l'intérieur du fichier. Il permet de définir des valeurs minimum et maximum
                et émettra une erreur si l'un ou l'autre des seuils est dépassé.
            </para>
        </listitem>
    </itemizedlist>

    <sect2 id="zend.file.transfer.validators.usage">
        <title>Utiliser les validateurs avec Zend_File_Transfer</title>

        <para>
            L'utilisation des validateurs est assez simple. Il existe de multiples méthodes
            pour ajouter et manipuler les validateurs.
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <methodname>isValid($files = null)</methodname>&#160;: vérifie le(s) fichier(s) fourni(s)
                    avec tout le jeu de validateurs paramétrés. <varname>$files</varname> peut être soit
                    un vrai nom de fichier, soit des noms d'éléments de formulaire ou des noms de
                    fichiers temporaires.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>addValidator($validator, $breakChainOnFailure, $options = null,
                    $files = null)</code>&#160;: ajoute le validateur à la pile des validateurs
                    (optionnellement seul le(s) fichier(s) spécifié(s)). <varname>$validator</varname>
                    peut être soit une instance d'un validateur réel, ou un nom court spécifiant le
                    validateur (par exemple, "Count").
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>addValidators(array $validators, $files = null)</methodname>&#160;: ajoute les
                    validateurs à la pile des validateurs. Chaque entrée peut être soit une paire
                    type/options, ou un tableau avec la clé "validator" spécifiant le validateur
                    (tous les autres options seront considérées comme des options du validateur au
                    moment de l'instanciation).
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>setValidators(array $validators, $files = null)</methodname>&#160;: surcharge
                    les validateurs existants avec les validateurs spécifiés. Les validateurs
                    doivent respecter la même syntaxe que <methodname>addValidators()</methodname>.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>hasValidator($name)</methodname>&#160;: indique si un validateur est enregistré.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>getValidator($name)</methodname>&#160;: retourne un validateur préalablement
                    enregistré.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>getValidators($files = null)</methodname>&#160;: retourne les validateurs
                    enregistrés&#160;; si <varname>$files</varname> est fourni, retourne les validateurs
                    pour ce fichier en particulier ou pour tous les fichiers.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>removeValidator($name)</methodname>&#160;: enlève le validateur préalablement
                    enregistré.
                </para>
            </listitem>

            <listitem>
                <para><methodname>clearValidators()</methodname>&#160;: efface tous les validateurs.</para>
            </listitem>
        </itemizedlist>

        <example id="zend.file.transfer.validators.usage.example">
            <title>Ajouter des validateurs au(x) fichier(s) transféré(s)</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Paramètre un poids de fichier de 20000 octets
$upload->addValidator('Size', false, 20000);

// Paramètre un poids de fichier de 20 octets minimum
// et de 20000 octets maximum
$upload->addValidator('Size', false, array('min' => 20, 'max' => 20000));

// Paramètre un poids de fichier de 20 octets minimum et
// de 20000 octets maximum et un nombre de fichiers en une seule étape
$upload->setValidators(array(
    'Size'  => array('min' => 20, 'max' => 20000),
    'Count' => array('min' => 1, 'max' => 3),
));
]]></programlisting>
        </example>

        <example id="zend.file.transfer.validators.usage.exampletwo">
            <title>Limiter les validateurs à des fichiers uniques</title>

            <para>
                <methodname>addValidator()</methodname>, <methodname>addValidators()</methodname>, et
                <methodname>setValidators()</methodname> accepte chacun un argument final <varname>$files</varname>.
                Cet argument peut être utilisé pour spécifier un fichier en particulier ou un
                tableau de fichiers sur lequel appliqué le validateur donné.
            </para>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Paramètre un poids de fichier de 20000 octets et
// limite celui-ci à 'file2'
$upload->addValidator('Size', false, 20000, 'file2');
]]></programlisting>
        </example>

        <para>
            Généralement vous devriez simplement utiliser la méthode
            <methodname>addValidators()</methodname>, qui peut être appelée plusieurs fois.
        </para>

        <example id="zend.file.transfer.validators.usage.examplemultiple">
            <title>Ajouter des validateurs multiples</title>

            <para>
                Souvent il est plus simple d'appeler plusieurs fois
                <methodname>addValidator()</methodname>&#160;: un appel pour chaque validateur. Ceci améliore
                aussi la lisibilité et rend votre code plus maintenable. Comme toutes les méthodes
                fournissent un interface fluide, vous pouvez enchaîner les appels comme montré
                ci-dessous&#160;:
            </para>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Paramètre un poids de fichier de 20000 octets
$upload->addValidator('Size', false, 20000)
       ->addValidator('Count', false, 2)
       ->addValidator('Filessize', false, 25000);
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que même si l'ajout du même validateur plusieurs fois est autorisé,
                faire ceci peut entraîner des problèmes si vous utilisez différentes options pour le
                même validateur.
            </para>
        </note>

        <para>
            Et pour finir vous pouvez tout simplement vérifier le(s) fichier(s) en appelant
            <methodname>isValid()</methodname>.
        </para>

        <example id="zend.file.transfer.validators.usage.exampleisvalid">
            <title>Valider les fichiers</title>

            <para>
                <methodname>isValid()</methodname> accepte les fichiers uploadés ou télécharger, le nom de
                fichier temporaire et bien sûr le nom de l'élément de formulaire. Si aucun paramètre
                ou <constant>NULL</constant> est fourni, tous les fichiers seront vérifiés.
            </para>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Paramètre un poids de fichier de 20000 octets
$upload->addValidator('Size', false, 20000)
       ->addValidator('Count', false, 2)
       ->addValidator('Filessize', false, 25000);

if ($upload->isValid()) {
    print "Echec de validation";
}
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que <methodname>isValid()</methodname> sera automatiquement appelé quand vous
                recevez les fichiers et qu'il n'a pas été appelé auparavant.
            </para>
        </note>

        <para>
            Quand une validation a échouée, c'est probablement intéressant d'avoir des
            informations sur les problèmes rencontrés. A cette fin, vous pouvez utiliser la méthode
            <methodname>getMessages()</methodname> qui retourne tous les messages de validation sous la forme
            d'un tableau, <methodname>getErrors()</methodname> qui retourne tous les codes d'erreurs et
            <methodname>hasErrors()</methodname> qui retourne <constant>TRUE</constant> dès qu'une erreur de validation
            est rencontrée.
        </para>
    </sect2>

    <sect2 id="zend.file.transfer.validators.count">
        <title>Validateur Count</title>

        <para>
            Le validateur <code>Count</code> vérifie le nombre de fichiers fournis. Il
            supporte les clés d'options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>min</code>&#160;: paramètre le nombre minimum de fichiers à
                    transférer.
                </para>

                <note>
                    <para>
                        Attention&#160;: quand vous utilisez cette option vous devez donner le
                        nombre minimum au moment où vous appelez ce validateur la première fois ;
                        sinon vous aurez une erreur en retour.
                    </para>
                </note>

                <para>
                    Avec cette option vous pouvez définir le nombre de fichiers que vous
                    souhaitez recevoir.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>max</code>&#160;: paramètre le nombre maximum de fichiers à
                    transférer.
                </para>

                <para>
                    Avec cette option vous pouvez limiter le nombre de fichiers que vous
                    acceptez mais vous permet aussi de détecter une possible attaque quand plus de
                    fichiers, que votre formulaire n'en définit, sont fournis.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Vous pouvez initialiser ce validateur avec une chaîne ou un entier, la valeur sera
            utilisée en tant que <code>max</code>. Mais vous pouvez aussi utiliser les méthodes
            <methodname>setMin()</methodname> et <methodname>setMax()</methodname> pour paramétrer ces options plus tard et
            <methodname>getMin()</methodname> et <methodname>getMax()</methodname> pour les récupérer.
        </para>

        <example id="zend.file.transfer.validators.count.example">
            <title>Utiliser le validateur Count</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite le nombre de fichiers à 2 maximum
$upload->addValidator('Count', false, 2);

// Limite le nombre de fichiers à 5 maximum,
// tout en obligeant au moins 1 fichier
$upload->addValidator('Count', false, array('min' =>1, 'max' => 5));
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que ce validateur stocke le nombre de fichiers vérifiés en interne. Le
                fichier qui excédera le maximum sera retourné en tant qu'erreur.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.crc32">
        <title>Validateur Crc32</title>

        <para>
            Le validateur <code>Crc32</code> vérifie le contenu du fichier transféré en le
            hachant. Ce validateur utilise l'extension de hachage de <acronym>PHP</acronym> avec l'algorithme crc32. Il
            supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Les valeurs seront utilisées pour vérifier la valeur de
                    hachage.
                </para>

                <para>
                    Vous pouvez paramétrer de multiples hachages en utilisant différentes
                    clés. Chacun sera vérifié et seulement si tous échouent, la validation elle-même
                    échouera.
                </para>
            </listitem>
        </itemizedlist>

        <example id="zend.file.transfer.validators.crc32.example">
            <title>Utiliser le validateur Crc32</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Vérifie si le contenu d'un fichier uploadé correspond au hachage fourni
$upload->addValidator('Crc32', false, '3b3652f');

// Limite ce validateur à deux différents hachages
$upload->addValidator('Crc32', false, array('3b3652f', 'e612b69'));
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.file.transfer.validators.excludeextension">
        <title>Validateur ExcludeExtension</title>

        <para>
            Le validateur <code>ExcludeExtension</code> vérifie l'extension des fichiers
            fournis. Il supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser un
                    tableau numérique. Les valeurs seront utilisées en tant qu'extensions à vérifier
                    que le fichier n'utilise pas.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>case</code>&#160;: paramètre une validation qui tient compte de la casse.
                    Par défaut, ce n'est pas sensible à la casse. Notez que cette clé est utilisée
                    pour toutes les extensions.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ce validateur accepte des extensions multiples soit sous la forme d'une chaîne
            utilisant le caractère virgule (",") comme séparateur ou sous la forme d'un tableau.
            Vous pouvez aussi utiliser les méthodes <methodname>setExtension()</methodname>,
            <methodname>addExtension()</methodname>, et <methodname>getExtension()</methodname> pour paramétrer et récupérer
            les extensions.
        </para>

        <para>
            Dans certains cas, il est utile vérifier aussi la casse. A cette fin le
            constructeur autorise un second paramètre <varname>$case</varname> qui, s'il est réglé à
            <constant>TRUE</constant>, validera l'extension en vérifiant aussi la casse.
        </para>

        <example id="zend.file.transfer.validators.excludeextension.example">
            <title>Utiliser le validateur ExcludeExtension</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Refuser les fichiers avec l'extension php ou exe
$upload->addValidator('ExcludeExtension', false, 'php,exe');

// Refuser les fichiers avec l'extension php ou exe en utilisant
// la notation de type tableau
$upload->addValidator('ExcludeExtension', false, array('php', 'exe'));

// Vérifier aussi la casse
$upload->addValidator('ExcludeExtension', false, array('php', 'exe', 'case' => true));
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que ce validateur ne vérifie que l'extension de fichier. Il ne vérifie
                pas le type <acronym>MIME</acronym> réel du fichier.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.excludemimetype">
        <title>Validateur ExcludeMimeType</title>

        <para>
            Le validateur <code>ExcludeMimeType</code> vérifie le type <acronym>MIME</acronym> des fichiers
            transférés. Il supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser un
                    tableau numérique. Paramètre le type <acronym>MIME</acronym> à vérifier.
                </para>

                <para>
                    Avec cette option vous pouvez définir le(s) type(s) <acronym>MIME</acronym> que vous
                    souhaitez exclure.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>headerCheck</code>&#160;: si spécifié à <constant>TRUE</constant>, cette
                    option va vérifier l'information <acronym>HTTP</acronym> concernant le type de
                    fichier quand les extensions <emphasis>fileInfo</emphasis> ou
                    <emphasis>mimeMagic</emphasis> ne seront pas trouvées. La valeur par défaut de
                    cette option est <constant>FALSE</constant>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ce validateur accepte des types <acronym>MIME</acronym> multiples soit sous la forme d'une chaîne
            utilisant le caractère virgule (",") comme séparateur ou sous la forme d'un tableau.
            Vous pouvez aussi utiliser les méthodes <methodname>setMimeType()</methodname>,
            <methodname>addMimeType()</methodname>, et <methodname>getMimeType()</methodname> pour paramétrer et récupérer
            les types <acronym>MIME</acronym>.
        </para>

        <example id="zend.file.transfer.validators.excludemimetype.example">
            <title>Utiliser le validateur ExcludeMimeType</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Refuser le type MIME d'image gif pour tous les fichiers
$upload->addValidator('ExcludeMimeType', false, 'image/gif');

// Refuser le type MIME d'image gif et jpg pour tous les fichiers
$upload->addValidator('ExcludeMimeType', false, array('image/gif', 'image/jpeg');

// Refuser les types MIME du groupe image pour tous les fichiers
$upload->addValidator('ExcludeMimeType', false, 'image');
]]></programlisting>
        </example>

        <para>
            L'exemple ci-dessus montre qu'il est aussi possible de limiter le type <acronym>MIME</acronym>
            accepté à un groupe de type <acronym>MIME</acronym>. Pour refuser toutes les images utilisez simplement
            "image" en tant que type <acronym>MIME</acronym>. Ceci peut être appliqué à tous les groupes de type <acronym>MIME</acronym>
            comme "image", "audio", "video", "text" et plus encore.
        </para>

        <note>
            <para>
                Notez que refuser un groupe de type <acronym>MIME</acronym> refusera tous les membres de ce
                groupe même si ce n'est pas votre intention. Par exemple quand vous refusez "image",
                vous refusez donc "image/jpeg" ou "image/vasa". Quand vous n'êtes pas sûr de vouloir
                refuser tous les types, vous devriez définir individuellement les types <acronym>MIME</acronym> plutôt
                que le groupe complet.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.exists">
        <title>Validateur Exists</title>

        <para>
            Le validateur <code>Exists</code> l'existence des fichiers fournis. Il supporte
            les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Vérifie si le fichier existe dans le dossier
                    fourni.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ce validateur accepte des extensions multiples soit sous la forme d'une chaîne
            utilisant le caractère virgule (",") comme séparateur ou sous la forme d'un tableau.
            Vous pouvez aussi utiliser les méthodes <methodname>setDirectory()</methodname>,
            <methodname>addDirectory()</methodname>, et <methodname>getDirectory()</methodname> pour paramétrer et récupérer
            les extensions.
        </para>

        <example id="zend.file.transfer.validators.exists.example">
            <title>Utiliser le validateur Exists</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Ajoute le dossier temporaire à vérifier
$upload->addValidator('Exists', false, '\temp');

// Ajoute deux dossiers en utilsant la notation de type tableau
$upload->addValidator('Exists',
                      false,
                      array('\home\images', '\home\uploads'));
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que ce validateur vérifie si le fichier existe dans tous les dossiers
                fournis. La validation échoue si le fichier est manquant dans l'un des
                dossiers.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.extension">
        <title>Validateur Extension</title>

        <para>
            Le validateur <code>Extension</code> vérifie l'=es extensions des fichiers qui ont
            été fournis. Il supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Paramètre l'extension à vérifier.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>case</code>&#160;: paramètre une validation sensible à la casse. Par
                    défaut, la validation n'est pas sensible à la casse. Notez que cette clé est
                    utilisée pour toutes les extensions.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ce validateur accepte des extensions multiples soit sous la forme d'une chaîne
            utilisant le caractère virgule (",") comme séparateur ou sous la forme d'un tableau.
            Vous pouvez aussi utiliser les méthodes <methodname>setExtension()</methodname>,
            <methodname>addExtension()</methodname>, et <methodname>getExtension()</methodname> pour paramétrer et récupérer
            les extensions.
        </para>

        <para>
            Dans certains cas, il est utile vérifier aussi la casse. A cette fin le
            constructeur autorise un second paramètre <varname>$case</varname> qui, s'il est réglé à
            <constant>TRUE</constant>, validera l'extension en vérifiant aussi la casse.
        </para>

        <example id="zend.file.transfer.validators.extension.example">
            <title>Utiliser le validateur Extension</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite les extensions à jpg et png
$upload->addValidator('Extension', false, 'jpg,png');

// Limite les extensions à jpg et png en utilisant
// la notation de type tableau
$upload->addValidator('Extension', false, array('jpg', 'png'));

// Vérifie aussi la casse
$upload->addValidator('Extension', false, array('mo', 'png', 'case' => true));
if (!$upload->isValid('C:\temp\myfile.MO')) {
    print 'Non valide à cause de MO au lieu de mo';
}
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que ce validateur ne vérifie que l'extension de fichier. Il ne vérifie
                pas le type <acronym>MIME</acronym> réel du fichier.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.filessize">
        <title>Validateur FilesSize</title>

        <para>
            Le validateur <code>FilesSize</code> vérifie le poids total de tous les fichiers
            transférés. Il supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para><code>min</code>&#160;: paramètre le poids minimum de tous les fichiers.</para>

                <para>
                    Avec cette option vous pouvez définir le poids minimum de tous les
                    fichiers que vous souhaitez transférer.
                </para>
            </listitem>

            <listitem>
                <para><code>max</code>&#160;: paramètre le poids maximum de tous les fichiers.</para>

                <para>
                    Avec cette option vous pouvez limiter le poids total des fichiers qui
                    doivent être transférés, mais pas la taille individuelle de chaque
                    fichier.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>bytestring</code>&#160;: définit si un échec est retourné avec un taille
                    plus facilement lisible pour l'utilisateur, ou avec une taille de fichier
                    brute.
                </para>

                <para>
                    Avec cette option vous pouvez en fait définir si l'utilisateur récupérera
                    "10864" ou "10MB". La valeur par défaut est <constant>TRUE</constant> qui retournera
                    "10MB".
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Vous pouvez initialiser seulement avec une chaîne qui sera utilisée en tant que
            <code>max</code>. Mais vous pouvez aussi utiliser les méthodes <methodname>setMin()</methodname> et
            <methodname>setMax()</methodname> pour paramétrer ces options plus tard et <methodname>getMin()</methodname> et
            <methodname>getMax()</methodname> pour les récupérer.
        </para>

        <para>
            La taille elle-même est acceptée en notation SI comme sur la plupart des systèmes
            d'exploitation. Au lieu de 20000 octets (NdT. : "bytes" en anglais), vous pouvez
            utiliser <emphasis>20kB</emphasis>. Toutes les unités sont converties en utilisant 1024
            comme valeur de base. Les unités suivantes sont acceptées : <code>kB</code>,
            <code>MB</code>, <code>GB</code>, <code>TB</code>, <code>PB</code> et <code>EB</code>.
            Comme mentionné précédemment vous devez noter que 1kB équivaut à 1024 octets.
        </para>

        <example id="zend.file.transfer.validators.filessize.example">
            <title>Utiliser le validateur FilesSize</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite la taille de tous les fichiers à 40000 octets
$upload->addValidator('FilesSize', false, 40000);

// Limite la taille de tous les fichiers dans une plage de 10kB à 4MB
$upload->addValidator('FilesSize', false, array('min' => '10kB',
                                                'max' => '4MB'));

// Comme ci-dessus, mais retourne la taille de fichier brute plutôt qu'une chaîne
$upload->addValidator('FilesSize', false, array('min' => '10kB',
                                                'max' => '4MB',
                                                'bytestring' => false));
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que ce validateur stocke le poids des fichiers vérifiés en interne. Le
                fichier qui excédera le poids maximum sera retourné en tant qu'erreur.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.imagesize">
        <title>Validateur ImageSize</title>

        <para>
            Le validateur <code>ImageSize</code> vérifie la taille des images. Il supporte les
            options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para><code>minheight</code>&#160;: paramètre la hauteur minimum d'une image.</para>
            </listitem>

            <listitem>
                <para><code>maxheight</code>&#160;: paramètre la hauteur maximum d'une image.</para>
            </listitem>

            <listitem>
                <para><code>minwidth</code>&#160;: paramètre la largeur minimum d'une image.</para>
            </listitem>

            <listitem>
                <para><code>maxwidth</code>&#160;: paramètre la largeur maximum d'une image.</para>
            </listitem>
        </itemizedlist>

        <para>
            Vous pouvez aussi utiliser les méthodes <methodname>setImageMin()</methodname> et
            <methodname>setImageMax()</methodname> pour régler les valeurs minimum et maximum plus tard et
            <methodname>getMin()</methodname> et <methodname>getMax()</methodname> pour les récupérer.
        </para>

        <para>
            Par commodité, il existe aussi les méthodes <code>setImageWidth</code> et
            <code>setImageHeight</code> qui paramètrent la largeur et la hauteur minimum et maximum.
            Bien sûr les méthodes associées <code>getImageWidth</code> et
            <code>getImageHeight</code> sont aussi disponibles.
        </para>

        <para>
            Pour désactiver la validation d'une dimension, ne paramétrez pas l'option
            correspondante.
        </para>

        <example id="zend.file.transfer.validators.imagesize.example">
            <title>Utiliser le validateur ImageSize</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite la taille de l'image à une hauteur de 100 à 200 et
// une largeur de 40 à 80 pixels
$upload->addValidator('ImageSize',
                      false,
                      array('minwidth' => 40,
                            'maxwidth' => 80,
                            'minheight' => 100,
                            'maxheight' => 200);

// Autre possibilité de réglage
$upload->setImageWidth(array('minwidth' => 20, 'maxwidth' => 200));
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.file.transfer.validators.iscompressed">
        <title>Validateur IsCompressed</title>

        <para>
            Le validateur <code>IsCompressed</code> vérifie si un fichier transféré est une
            archive compressée comme zip ou arc. Ce validateur est basée sur le validateur
            <code>MimeType</code> et supportent les mêmes méthodes et options. Vous pouvez limiter
            ce validateur à des types de compression particuliers avec les méthodes décrites
            ci-dessous.
        </para>

        <example id="zend.file.transfer.validators.iscompressed.example">
            <title>Utiliser le validateur IsCompressed</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Vérifie si un fichier uploadé est une archive compressée
$upload->addValidator('IsCompressed', false);

// Limite ce validateur aux fichiers zip seulement
$upload->addValidator('IsCompressed', false, array('application/zip'));

// Limite ce validateur aux fichiers zip mais avec la notation simplifiée
$upload->addValidator('IsCompressed', false, 'zip');
]]></programlisting>
        </example>

        <note>
            <para>
                Notez qu'il n'y a pas de vérification si vous paramétrez un type de fichier
                qui n'est pas un type de compression. Ainsi il est donc possible de définir que les
                fichiers gif sont acceptés par ce validateur même si ce n'est pas logique.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.isimage">
        <title>Validateur IsImage</title>

        <para>
            Le validateur <code>IsImage</code> vérifie si un fichier transféré est une image
            comme gif ou jpeg. Ce validateur est basée sur le validateur <code>MimeType</code> et
            supportent les mêmes méthodes et options. Vous pouvez limiter ce validateur à des types
            d'image particuliers avec les méthodes décrites ci-dessous.
        </para>

        <example id="zend.file.transfer.validators.isimage.example">
            <title>Utiliser le validateur IsImage</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Vérifie si un fichier uploadé est une image
$upload->addValidator('IsImage', false);

// Limite ce validateur aux fichiers gif seulement
$upload->addValidator('IsImage', false, array('application/gif'));

// Limite ce validateur aux fichiers jpeg mais avec la notation simplifiée
$upload->addValidator('IsImage', false, 'jpeg');
]]></programlisting>
        </example>

        <note>
            <para>
                Notez qu'il n'y a pas de vérification si vous paramétrez un type de fichier
                qui n'est pas un type d'image. Ainsi il est donc possible de définir que les
                fichiers zip sont acceptés par ce validateur même si ce n'est pas logique.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.hash">
        <title>Validateur Hash</title>

        <para>
            Le validateur <code>Hash</code> vérifie le contenu du fichier transféré en le
            hachant. Ce validateur utilise l'extension de hachage de <acronym>PHP</acronym>. Il supporte les options
            suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Paramètre la valeur de hachage qui doit être
                    vérifié.
                </para>

                <para>
                    Vous pouvez paramétrer de multiples hachages en les fournissant sous la
                    forme d'un tableau. Chacun sera vérifié et seulement si tous échouent, la
                    validation elle-même échouera.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                    <code>algorithm</code>&#160;: paramètre l'algorithme à utiliser pour hacher le
                    contenu.
                </para>

                <para>
                    Vous pouvez paramétrer de multiples algorithmes en utilisant la méthode
                    <methodname>addHash()</methodname> plusieurs fois.
                </para>
            </listitem>
        </itemizedlist>

        <example id="zend.file.transfer.validators.hash.example">
            <title>Utiliser le validateur Hash</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Vérifie si le contenu d'un fichier uploadé correspond au hachage fourni
$upload->addValidator('Hash', false, '3b3652f');

// Limite ce validateur à deux différents hachages
$upload->addValidator('Hash', false, array('3b3652f', 'e612b69'));

// Paramètre un algorithme différent pour effectuer le hachage
$upload->addValidator('Hash', false, array('315b3cd8273d44912a7', 'algorithm' => 'md5'));
]]></programlisting>
        </example>

        <note>
            <para>
                Ce validateur supporte environ 34 algorithmes de hachage différents. Les plus
                connus sont "crc32", "md5" and "sha1". Si vous souhaitez connaître les autres
                algorithmes, voyez <ulink url="http://php.net/manual/fr/function.hash-algos.php">la
                méthode hash_algos de <acronym>PHP</acronym></ulink>.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.md5">
        <title>Validateur Md5</title>

        <para>
            Le validateur <code>Md5</code> vérifie le contenu du fichier transféré en le
            hachant. Ce validateur utilise l'extension de hachage de <acronym>PHP</acronym> avec l'algorithme md5. Il
            supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Paramètre la valeur de hachage qui doit être
                    vérifié.
                </para>

                <para>
                    Vous pouvez paramétrer de multiples hachages en les fournissant sous la
                    forme d'un tableau. Chacun sera vérifié et seulement si tous échouent, la
                    validation elle-même échouera.
                </para>
            </listitem>
        </itemizedlist>

        <example id="zend.file.transfer.validators.md5.example">
            <title>Utiliser le validateur Md5</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Vérifie si le contenu d'un fichier uploadé correspond au hachage fourni
$upload->addValidator('Md5', false, '3b3652f336522365223');

// Limite ce validateur à deux différents hachages
$upload->addValidator('Md5', false, array('3b3652f336522365223', 'eb3365f3365ddc65365'));
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.file.transfer.validators.mimetype">
        <title>Validateur MimeType</title>

        <para>
            Le validateur <code>MimeType</code> vérifie le type <acronym>MIME</acronym> des fichiers transférés.
            Il supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser un
                    tableau numérique. Paramètre le type <acronym>MIME</acronym> à contrôler.
                </para>

                <para>
                    Avec cette option vous pouvez définir le type <acronym>MIME</acronym> des fichiers qui seront
                    acceptés.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>headerCheck</code>&#160;: si spécifié à <constant>TRUE</constant>, cette
                    option va vérifier l'information <acronym>HTTP</acronym> concernant le type de
                    fichier quand les extensions <emphasis>fileInfo</emphasis> ou
                    <emphasis>mimeMagic</emphasis> ne seront pas trouvées. La valeur par défaut de
                    cette option est <constant>FALSE</constant>.
                </para>
            </listitem>

            <listitem>
                <para><code>magicfile</code>&#160;: le magicfile qui sera utilisé.</para>

                <para>
                    Avec cette option vous pouvez définir le magicfile à utiliser. Quand il
                    n'est pas utilisé ou vide, la constante <constant>MAGIC</constant> sera utilisée. Cette
                    option est disponible à partir de la version 1.7.1 de Zend Framework.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ce validateur accepte des types <acronym>MIME</acronym> multiples soit sous la forme d'une chaîne
            utilisant le caractère virgule (",") comme séparateur ou sous la forme d'un tableau.
            Vous pouvez aussi utiliser les méthodes <methodname>setMimeType()</methodname>,
            <methodname>addMimeType()</methodname>, et <methodname>getMimeType()</methodname> pour paramétrer et récupérer
            les types <acronym>MIME</acronym>.
        </para>

        <para>
            Vous pouvez aussi paramétrer le magicfile qui sera utilisé par fileinfo avec
            l'option <code>magicfile</code>. De plus il existe les méthodes
            <methodname>setMagicFile()</methodname> et <methodname>getMagicFile()</methodname> qui permettent de paramétrer
            ou récupérer plus tard le paramètre <code>magicfile</code>. Ces méthodes sont
            disponibles à partir de la version Zend Framework 1.7.1.
        </para>

        <example id="zend.file.transfer.validators.mimetype.example">
            <title>Utiliser le validateur MimeType</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite le type MIME de tous les fichiers aux images gif
$upload->addValidator('MimeType', false, 'image/gif');

// Limite le type MIME de tous les fichiers aux images jpeg et gif
$upload->adValidator('MimeType', false, array('image/gif', 'image/jpeg');

// Limite le type MIME de tous les fichiers au groupe des images
$upload->addValidator('MimeType', false, 'image');

// Utilise un magicfile différent
$upload->addValidator('MimeType', false, array('image', 'magicfile' => '/path/to/magicfile.mgx'));
]]></programlisting>
        </example>

        <para>
            L'exemple ci-dessus montre qu'il est aussi possible de limiter le type <acronym>MIME</acronym>
            accepté à un groupe de type <acronym>MIME</acronym>. Pour autoriser toutes les images utilisez simplement
            "image" en tant que type <acronym>MIME</acronym>. Ceci peut être appliqué à tous les groupes de type <acronym>MIME</acronym>
            comme "image", "audio", "video", "text" et plus encore.
        </para>

        <note>
            <para>
                Notez qu'autoriser un groupe de type <acronym>MIME</acronym> acceptera tous les membres de ce
                groupe même si votre application ne les supporte pas. Par exemple quand vous
                autorisez "image", vous autorisez donc "image/xpixmap" ou "image/vasa", ce qui peut
                être problématique. Quand vous n'êtes pas sûr que votre application supporte tous
                les types, vous devriez définir individuellement les types <acronym>MIME</acronym> plutôt que le groupe
                complet.
            </para>
        </note>

        <note>
            <para>
                Ce composant utilise l'extension <code>fileinfo</code> si elle est disponible.
                Si ce n'est pas le cas, il utilisera alors la fonction
                <code>mime_content_type</code>. Et si l'appel de fonction échoue, il utilisera le
                type <acronym>MIME</acronym> fourni par <acronym>HTTP</acronym>.
            </para>

            <para>
                Vous devez cependant être averti de possibles problèmes de sécurité si, ni
                <code>fileinfo</code>, ni <code>mime_content_type</code> ne sont disponibles : le
                type <acronym>MIME</acronym> fourni pas <acronym>HTTP</acronym> n'étant pas sécurisé et pouvant être facilement
                manipulé.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.notexists">
        <title>Validateur NotExists</title>

        <para>
            Le validateur <code>NotExists</code> l'existence des fichiers fournis. Il supporte
            les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Vérifie si le fichier n'existe pas dans le dossier
                    fourni.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ce validateur accepte des extensions multiples soit sous la forme d'une chaîne
            utilisant le caractère virgule (",") comme séparateur ou sous la forme d'un tableau.
            Vous pouvez aussi utiliser les méthodes <methodname>setDirectory()</methodname>,
            <methodname>addDirectory()</methodname>, et <methodname>getDirectory()</methodname> pour paramétrer et récupérer
            les extensions.
        </para>

        <example id="zend.file.transfer.validators.notexists.example">
            <title>Utiliser le validateur NotExists</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Ajoute le dossier temporaire à vérifier
$upload->addValidator('NotExists', false, '\temp');

// Ajoute deux dossiers en utilisant la notation de type tableau
$upload->addValidator('NotExists',
                      false,
                      array('\home\images',
                            '\home\uploads'));
]]></programlisting>
        </example>

        <note>
            <para>
                Notez que ce validateur vérifie si le fichier n'existe dans aucun des dossiers
                fournis. La validation échoue si le fichier existe dans l'un des dossiers.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.file.transfer.validators.sha1">
        <title>Validateur Sha1</title>

        <para>
            Le validateur <code>Sha1</code> vérifie le contenu du fichier transféré en le
            hachant. Ce validateur utilise l'extension de hachage de <acronym>PHP</acronym> avec l'algorithme sha1. Il
            supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>*</code>&#160;: vous pouvez paramétrer n'importe quelle clé ou utiliser
                    un tableau numérique. Paramètre la valeur de hachage qui doit être
                    vérifié.
                </para>

                <para>
                    Vous pouvez paramétrer de multiples hachages en les fournissant sous la
                    forme d'un tableau. Chacun sera vérifié et seulement si tous échouent, la
                    validation elle-même échouera.
                </para>
            </listitem>
        </itemizedlist>

        <example id="zend.file.transfer.validators.sha1.example">
            <title>Utiliser le validateur Sha1</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Vérifie si le contenu d'un fichier uploadé correspond au hachage fourni
$upload->addValidator('Sha1', false, '3b3652f336522365223');

// Limite ce validateur à deux différents hachages
$upload->addValidator('Sha1', false, array('3b3652f336522365223', 'eb3365f3365ddc65365'));
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.file.transfer.validators.size">
        <title>Validateur Size</title>

        <para>
            Le validateur <code>Size</code> vérifie le poids d'un fichier unique. Il supporte
            les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para><code>min</code>&#160;: paramètre le poids minimum du fichier.</para>
            </listitem>

            <listitem>
                <para><code>max</code>&#160;: paramètre le poids maximum du fichier.</para>
            </listitem>

            <listitem>
                <para>
                    <code>bytestring</code>&#160;: définit si un échec est retourné avec un taille
                    plus facilement lisible pour l'utilisateur, ou avec une taille de fichier
                    brute.
                </para>

                <para>
                    Avec cette option vous pouvez en fait définir si l'utilisateur récupérera
                    "10864" ou "10MB". La valeur par défaut est <constant>TRUE</constant> qui retournera
                    "10MB".
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Vous pouvez initialiser seulement avec une chaîne qui sera utilisée en tant que
            <code>max</code>. Mais vous pouvez aussi utiliser les méthodes <methodname>setMin()</methodname> et
            <methodname>setMax()</methodname> pour paramétrer ces options plus tard et <methodname>getMin()</methodname> et
            <methodname>getMax()</methodname> pour les récupérer.
        </para>

        <para>
            Quand seule une chaîne est fournie, elle est utilisée en tant que
            <code>max</code>. Mais vous pouvez aussi utiliser les méthodes <methodname>setMin()</methodname> et
            <methodname>setMax()</methodname> pour paramétrer ces options plus tard et <methodname>getMin()</methodname> et
            <methodname>getMax()</methodname> pour les récupérer.
        </para>

        <para>
            La taille elle-même est acceptée en notation SI comme sur la plupart des systèmes
            d'exploitation. Au lieu de 20000 octets, vous pouvez utiliser <emphasis>20kB</emphasis>.
            Toutes les unités sont converties en utilisant 1024 comme valeur de base. Les unités
            suivantes sont acceptées : <code>kB</code>, <code>MB</code>, <code>GB</code>,
            <code>TB</code>, <code>PB</code> et <code>EB</code>. Comme mentionné précédemment vous
            devez noter que 1kB équivaut à 1024 octets.
        </para>

        <example id="zend.file.transfer.validators.size.example">
            <title>Utiliser le validateur Size</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite la taille d'un fichier à 40000 octets
$upload->addValidator('Size', false, 40000);

// Limite la taille du fichier 'uploadfile' dans une plage de 10kB à 4MB
// Additionally returns the plain number in case of an error instead of a userfriendly one
$upload->addValidator('Size', false, array('min' => '10kB',
                                           'max' => '4MB',
                                           'bytestring' => false));
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.file.transfer.validators.wordcount">
        <title>Validateur WordCount</title>

        <para>
            Le validateur <code>WordCount</code> vérifie le nombre de mots à l'intérieur des
            fichiers fournis. Il supporte les options suivantes&#160;:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>min</code>&#160;: spécifie le nombre de mots minimum qui doivent être
                    trouvés.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>max</code>&#160;: spécifie le nombre de mots maximum qui doivent être
                    trouvés.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Si vous initialisez ce validateur avec une chaîne ou un entier, la valeur sera
            utilisée en tant que <code>max</code>. Mais vous pouvez aussi utiliser les méthodes
            <methodname>setMin()</methodname> et <methodname>setMax()</methodname> pour paramétrer ces options plus tard et
            <methodname>getMin()</methodname> et <methodname>getMax()</methodname> pour les récupérer.
        </para>

        <example id="zend.file.transfer.validators.wordcount.example">
            <title>Utiliser le validateur WordCount</title>

            <programlisting language="php"><![CDATA[
$upload = new Zend_File_Transfer();

// Limite le nombre maximum de mots dans les fichiers à 2000
$upload->addValidator('WordCount', false, 2000);

// Limite le nombre de mots dans les fichiers entre un minimum de 1000
// et un maximum de 5000 mots
$upload->addValidator('WordCount', false, array('min' => 1000, 'max' => 5000));
]]></programlisting>
        </example>
    </sect2>
</sect1>